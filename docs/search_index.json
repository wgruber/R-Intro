[
["index.html", "Reinführung in RStudio Vorwort", " Reinführung in RStudio Walter Gruber 2019-01-20 Vorwort Dieser Kurs richtet sich vor allem an jene Personen, die weder Erfahrungen in der Programmierung im Allgemeinen, noch im Umgang mit R im Speziellen haben. Programme zu schreiben ist nicht allzu schwer. Man muss sich ein paar Regeln der verwendeten Programmiersprache aneignen und schon kann es losgehen. Gute Programme zu schreiben ist schon etwas schwieriger, aber auch das ist mit etwas Aufwand durchaus machbar. Häufig wird am Beginn einer Karriere als Programmierer der Fehler gemacht, sich zu sehr auf Details zu konzentrieren und dabei den Überblick des eigentlichen Ziels eines Programmes zu verlieren. Während der Programmierung sollte man sich stets darüber im Klaren sein, dass ein Computerprogramm immer genau das macht, was man ihm sagt und nichts macht, was man ihm nicht sagt. Was uns oft klar und logisch erscheint, bleibt für ein Computerprogramm so lange undurchführbar, bis man es durch detaillierte Schritt für Schritt Instruktionen mit unserer Logik und Idee vertraut gemacht hat. Wenn das gelingt, wird es ein treuer Partner sein und mit einer unbestechlichen Präzision diese Logik hunderte, oder millionenmal abarbeiten, ohne einen einzigen Fehler dabei zu begehen. Für Einsteiger ist es oft schwierig zu beurteilen, in welcher Reihenfolge und in welchem Detail Instruktionen für den Computer gegeben werden müssen. Daher ist es primäres Ziel dieser LV, die grundlegenden Elemente der Programmiersprache R kennen zulernen und diese richtig anzuwenden. Dabei werden wir auch Hilfsmittel kennen lernen, die den Einstieg in R wesentlich erleichtern können. "],
["aufbau-des-kurses.html", "1 Aufbau des Kurses Ziele Allgemeines", " 1 Aufbau des Kurses Im Lauf des Kurses werden wir abwechselnd zwei unterschiedliche Ansätze des Lernens verwenden. Ich habe diese Ansätze Top-Down und Bottom-Up genannt und werde die Idee dahinter noch im Detail erklären. Der Einstieg in R wird wesentlich durch die Verwendung von RStudio erleichtert. Wir werden im Folgenden die Eigenschaften und den Umgang mit diesem Programm im Detail besprechen. Unabhängig von der Vorgehensweise werden wir jeweils zu den behandelten Themen direkt Übungen in R durchführen. Diese Übungen sind zum Großteil in den vorliegenden Unterlagen beschrieben und der entsprechende R-Code kann direkt aus diesen Unterlagen ins RStudio übernommen und ausgeführt werden. Des Weiteren sind zwischen den Kursterminen Hausübungen zu bearbeiten. Den genauen Ablauf werde ich während der Lehrveranstaltung bekannt geben. Zur Beurteilung eurer Leistungen in der LV sind interaktive Online-Fragen zu bearbeiten. Auch hierzu werde ich Details während der LV bekannt geben. Ziele Aufbau von R-Studio. wo und wie findet man nützliche Infos zu R und RStudio. Definition von Daten und Objekten in R grundlegende Logik von Befehlen und Funktionen in R. Daten einlesen und bearbeiten. einfache deskriptive Statistiken anfordern. einfache Graphiken erstellen und bearbeiten. einige nützliche (statistische) Funktionen kennen. Allgemeines Nachfolgend ein kurzer Überblick über die Entstehungsgeschichte von R. Entstehungsgeschichte von R1 Abbildung 1: von F zu R Entwickelt 1992, orientiert sich R eng an Sprache S. Weitere Inspirationsquelle war die Programmiersprache Scheme. 1993 wurde die Software erstmals öffentlich vorgestellt und seit Juni 1995 steht R unter der GNU General Public License. Bis 1996 oder 1997 gab es zwischen 50 und 100 Leute in einer Mailingliste, die dabei halfen die Sprache gemeinsam zu verbessern. Im Jahr 1997 wurde das R Development Core Team gebildet (heute R Core Team), das sich um die Weiterentwicklung von R kümmert und den Quellcode verändern kann. Das Comprehensive R Archive Network (CRAN) als Plattform für Pakete startete am 23. April 1997 um Anwendern die Möglichkeit zu geben selbst geschriebene Funktionen leichter mit Anderen zu teilen. Seit April 2001 gibt es R für macOS. Im September 2002 gründeten die Mitglieder des R Development Core Teams den gemeinnützigen Verein The R Foundation for Statistical Computing in Wien, welcher sich um die Außendarstellung kümmert. Die R-Version 2.0 wurde am 4. Oktober 2004 veröffentlicht. Seitdem nutzt R Lazy Loading, um Daten bei geringer Beanspruchung des Arbeitsspeichers schnell laden zu können. Ab Version 2.1 (18. April 2005) unterstützt R unterschiedliche Sprachversionen (Internationalisierung) und Zeichenkodierungen, insbesondere UTF-8. Mit die Einführung von Version 2.11 im April 2010, die R auf 64-Bit-Systemen nutzbar macht und bis zu acht Terabyte Arbeitsspeicher adressieren kann gelang der Einstieg in Big-Data-Processing. Im Oktober 2011 (Version 2.14) wurde die parallele Ausführung von Funktionen eingeführt. Neben all diesen technischen Entwicklungen wurden unzählige Pakete für alle erdenklichen Anwendungsbereiche durch die Community entwickelt. Derzeit (Stand November 2018) gibt es 13.346 packages (mit dem Befehl available.packages()) kann man das jederzeit abfragen) allein auf CRAN! Dabei sind die Packages anderer Repositories (z.B. Bioconductor2 mit 1.649 packages) noch nicht berücksichtigt! Warum sollte man R verwenden? R ist eine Programmiersprache, die besonders zur Analyse und Visualisierung von Daten genutzt wird. Sehr viele Neuentwicklungen in der Statistik passieren in R. Auch ohne Vorkenntnisse in einer Programmiersprache findet man sich in R schnell zurecht. Mit Hilfe von RStudio, den unzähligen Tutorials und Hilfeseiten gelingt es schon nach sehr kurzer Zeit die ersten hilfreichen Programme zu schreiben. Alle diese Tools sind open source, d.h. transparent, eigenständig veränderbar und vor allem kostenlos. Stellt man die Vor- und Nachteile der Nutzung von R gegenüber, lässt sich die Entscheidung Arbeit in R hineinzustecken relativ leicht rechtfertigen: Vorteile Neben gängigen Programmen zur statistischen Auswertung, wie beispielsweise “SPSS” bietet R den Vorteil, dass es auf der ganzen Welt kostenlos zur Verfügung steht. R kann die meisten gängigen Formate importieren und bietet ein quelloffenes Format für erstellte Datensätze. Darüber hinaus stellt R mächtigere und mehr Auswertungsverfahren zur Verfügung als viele andere Programme. R ist eine Programmierumgebung. Funktionen können bequem den eigenen Bedürfnissen angepasst werden. Komplexe Probleme lassen sich auch dann lösen, wenn die Entwickler diese (noch) nicht implementiert haben. R wird von der Scientific Community kontinuierlich weiterentwickelt. Neue statistische Verfahren werden in der Regel auch in R integriert. Ein standardisiertes Pakete-System erleichtert die Nachinstallation ebenso wie die Veröffentlichung eigener Pakete. R erstellt professionelle Graphiken in einer Vielzahl an Formaten. R erleichtert durch z.T. selbstdokumentierende Codes die Reproduzierbarkeit von Studien. R bietet eine Vielzahl an Online-Tutorials, Blogs und sonstige Hilfestellungen. Nachteile Für den Anfänger ist die Funktionsweise und Bedienung von R zweifellos gewöhnungsbedürftig. die Formatierung von Ergebnisse in R (Tabellen, Graphiken, etc.) muss häufig durch zusätzliche Programmschritte vom Benutzer durchgeführt werden. R ist prinzipiell Code-basiert. Benutzerfreundliche Interaktionsfenster zur Parametrisierung von Analysen müssen durch den Programmierer mit Hilfe entsprechender Programmpakete (z.B. Shiny, Java, etc.) selbst erstellt werden. Wann sollte man R verwenden? Ein HardcoRe’ler würde diese Frage nicht verstehen und sich wahrscheinlich kopfschüttelnd wieder der Programmierung widmen, ohne den Fragesteller weiter zu beachten. Für alle anderen stellt sich jedoch die Frage, ob und ab wann sich der Aufwand eine Programmiersprache zu erlernen lohnt. Das kann eigentlich nur jeder für sich selbst entscheiden. Gute Gründe könnten z.B. sein, wenn: keine finanziellen Mittel zur Anschaffung einer kostenpflichtigen Statistiksoftware vorhanden sind. die zur Verfügung stehende Software ist nicht in der Lage, ein vorliegendes statistisches Problem zu lösen. man in einem Team eine Auswertungsstrategie (sanity checks, Standardprozeduren, etc.) entwickeln möchte. dynamisches Reporting im Ablauf eines Forschungsprozesses verwendet werden soll. Wann sollte man R nicht verwenden? Geht es einzig und allein darum, einen Datensatz explorativ und/oder mit gängigen Analysemethoden zu bearbeiten, kann man auf bereits bestehende und benutzerfreundliche Anwendungen zurückgreifen. Wir werden uns im folgenden zwei durchaus brauchbare Programmpakete kurz ansehen. Stehen Programme wie SPSS, SAS o.ä. zur Verfügung, sollte man sich vor den Einstieg in R klar über die gesteckten Ziele sein und eine Kosten-Nutzen-Rechnung anstellen. Sehr oft ist es viel einfacher, sich in die Syntax des jeweiligen Programms einzuarbeiten, als alles in R zu lösen. Es sei auch darauf hingewiesen, dass (zumindest) SPSS bereits eine Schnittstelle mit R anbietet. Details dazu sind in den entsprechenden Manuals nachzulesen. Weitere wichtige Überlegungen bezüglich der Umstellung/Einführung von R sind: wie viele Mitarbeiter verwenden ein statistisches Auswerteprogramm und wie viele davon müssten sich in R einarbeiten. welche Auswertungsmethoden will ich langfristig gesehen einsetzen? Sind dabei Verfahren, die mit SPSS, SAS, etc. nicht umsetzbar sind? Wie sehr kann ich mich auf die Korrektheit der Ergebnisse aus R verlassen? Immerhin ist ja alles Freeware und es wird keine Haftung für die Richtigkeit der Ergebnisse übernommen. Spielt das eine Rolle für meine Entscheidung? Alternativen zu R HardcoRe’ler kennen das Wort Alternative im Zusammenhang mit R nicht. Daher geben die nachfolgende Abbildungen einen Überblick über die derzeit (Stand Nov. 2018) wesentlichen Statistikprogramme am Markt3, ohne den Anspruch zu erheben, eine echte Alternative zu R zu sein. Freie Software: Abbildung 2: frei verfügbare Statistikprogramme Proprietäre Software: Abbildung 3: kostenpflichtige Statistikprogramme Mit Stand November 2018 war laut Tiobe4 R an 14 Stelle - 3 Stellen vor Matlab! SPSS ist in der aktuellen Bewertungsliste nicht angeführt. Der Nutzungsverlauf von R seit 2010 lässt vermuten, dass R auch in den kommenden Jahren an Bedeutung für die statistische Analyse beibehält, wenn nicht noch wesentlich weiterentwickelt. Abbildung 4: Verlauf des TIOBE-Index für R seit 2008 (the ratings are calculated by counting hits of the most popular search engines. The number of hits determines the ratings of a language. The counted hits are normalized for each search engine for all languages in the list. In other words, all languages together have a score of 100%.) Zusätzlich zu dieser Liste gibt es noch viele weitere Anwendungen, die zum Teil für ganz spezielle Analysetechniken maßgeschneidert wurden - falls erforderlich einfach im Web danach suchen. JAMOVI Ist ein Computerprogramm zur Datenanalyse und Durchführung von statistischen Tests. Abbildung 5: Kurzbeschreibung von JAMOVI Jamovi benutzt für die statistischen Auswertungen R. Damit bietet sich diese Programm auch an, bei Bedarf zwischen der bequemen Benutzung von JAMOVI und einer ins Detail gehenden Weiterentwicklung von JAMOVI-Programmen zu wechseln. Die Voraussetzungen um problemlos zwischen R und JAMOVI zu wechseln bietet das Paket jmv. Um den in JAMOVI verwendeten R Code sichtbar zu machen, ist folgende Einstellung in JAMOVI zu wählen: Abbildung 6: Darstellung des R-Codes in JAMOVI Kopiert man den Codeteil von JAMOVI nach R, kann dieser bearbeitet/erweitert werden: rm(list = ls()) if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) pacman::p_load(here, jmv, xtable) options(digits=3) DatenFile &lt;- &quot;/Heart Rate.csv&quot; D2L &lt;- paste0(here(&quot;Data&quot;), DatenFile) data &lt;- read.csv(D2L, check.names = FALSE) jmv::anova(data = data, dep = &quot;Heart Rate&quot;, factors = c(&quot;Gender&quot;, &quot;Group&quot;), emMeans = list(NULL)) # Erweiterung in R: Angabe der Effektgrößen in Tabelle jmv::anova(data = data, dep = &quot;Heart Rate&quot;, factors = c(&quot;Gender&quot;, &quot;Group&quot;), emMeans = list(NULL), effectSize = c(&#39;eta&#39;, &#39;partEta&#39;, &#39;omega&#39;)) # Diese Zeile wurde in R hinzugefügt JASP Ist ebenfalls ein Computerprogramm zur Datenanalyse und Durchführung von statistischen Tests. JASP hat einen ähnlichen Funktionsumfang wie JAMOVI. Als Besonderheit kann gelten, dass die meisten Funktionen neben der üblichen (“frequentistischen”) Form auch in einer zweiten Form, basierend auf der bayesschen Statistik, verfügbar sind. Der Funktionsumfang kann - wie auch bei JAMOVI - durch Module erweitert werden. Abbildung 7: Kurzbeschreibung von JASP Bei JASP sind neben der Bayesschen Statistik auch die verfügbaren Datensätze für den Einstieg in die Nutzung dieses Programm erwähnenswert. Sortiert nach Themenbereichen und referenziert nach Herkunft kann man einerseits mit den entsprechenden Verfahren experimentieren und gegebenenfalls auch noch in der Literatur nachschlagen - welche eben die gleichen Datensätze zur Erklärung der Verfahren verwendet. Man kann diese Daten aber auch exportieren und in JAMOVI verwenden! Geschichte von R - Wikipedia↩ Bioconductor - Software for Bioinformatics↩ Statistische Software Wikipedia↩ TIOBE Programming Community Index↩ "],
["rstudio5.html", "2 RStudio5 Aufbau von RStudio R-Syntax Kommandozeile (Befehlszeile, Console) Mathematische Operatoren/Funktionen Hilfe in RStudio Terminal-Fenster R-Markdown-Fenster Lösungen", " 2 RStudio5 RStudio ist eine vom Unternehmen RStudio, Inc. angebotene, integrierte Entwicklungsumgebung und grafische Benutzeroberfläche für die statistische Programmiersprache R. Bei RStudio handelt es sich um eine IDE6-Anwendung, ein Begriff den man häufig bei der Beschreibung von RStudio verwendet. RStudio ist sowohl als lokale Desktop-Version als auch als Server-Version mit gleichem Layout verfügbar. Die Umgebung teilt sich in vier Fenster (Panes), in denen: eines für die Erstellung von Skripten genutzt wird, ein anderes als Kommandozeile mit Output des Programmiercodes und ein weiteres für die Anzeige von Objekten in der Arbeitsumgebung. In einem vierten Bereich lassen sich mit Reitern grafischer Output, eine Paketverwaltung, das Ordnerverzeichnis und mehr anzeigen. RStudio bietet eine umfangreiche Entwicklungsumgebung und ermöglicht eine Vielzahl sehr hilfreicher Funktionalitäten, wie: Autovervollständigung, automatische Einrückungen, Syntaxhervorhebung. Code-Faltung. integrierte Hilfe und Informationen zu Objekten in der Arbeitsumgebung. Datensätze betrachten und bearbeiten. Zusammenfassen von Skripten, Daten und weitere Dateien zu Projekten (.Rproj), was die Zusammenarbeit erleichtert, zumal eine Versionsverwaltung mit Git enthalten ist. Mit Hilfe der Paketverwaltung lassen sich Pakete installieren und laden. Die Erstellung von Berichten mit Hilfe von knitr oder Sweave kann aus RStudio heraus erfolgen. Ein grafischer Debugger ist enthalten. Zudem kann Code in C, C++ oder Fortran kompiliert werden und direkt eingebunden werden. Für beide Ausführungen (Desktop, Server) von RStudio kann auch eine kommerzielle Variante erworben werden, die Support einschließt. Mit der kommerziellen Serverversion können mehrere Sitzungen parallel laufen und unterschiedliche Versionen von R verwendet werden. Außerdem sind das Teilen von Projekten und das Ressourcenmanagement einfacher. Aufbau von RStudio Beim Erststart von RStudio werden drei Fenster angezeigt. Für die effiziente Entwicklung von R-Programmen verwendet man einen Editor, welcher im RStudio integriert ist. Die Verwendung des Editors öffnet ein viertes Fenster. Diese vier Fenster bilden im Allgemeinen das Arbeitsumfeld mit RStudio. Konsole Environment Files Source Die standardmäßige Anordnung und Anzeige von Details innerhalb der Fenster kann durch den Benutzer angepasst werden. Details dazu werden bei den jeweiligen Kapiteln besprochen. R-Syntax In verschiedenen Programmiersprachen werden z.B. Groß- und Kleinschreibung, Dezimaltrennzeichen, Sonderzeichen etc. unterschiedlich definiert. Für R gelten folgende (grundlegende) Regeln: R unterscheidet zwischen Groß- und Kleinschreibung. Dezimaltrennzeichen: Punkt statt Komma. Keine Leerzeichen in Objektnamen, besser: my.object, my_object oder MyObject usw. Keine arithmetischen Operatoren (+,-,/) in Objektnamen. Erstes Zeichen eines Objektnamens muss ein Buchstabe sein. Befehle dürfen über mehrere Zeilen gehen. Alles, was existiert, ist ein Objekt. Kommandozeile (Befehlszeile, Console) Die Kommandozeile, Befehlszeile (command-line interface, CLI), oft auch als Konsole oder Terminal bezeichnet, ist ein Eingabebereich (interface) für die Steuerung einer Software, der typischerweise (aber nicht zwingend) im Textmodus abläuft. Die Kommandos oder Befehle werden als Zeichenketten über die Tastatur eingegeben. Die Ausführung der Befehle wird meist direkt aus der Zeile durch zusätzlich angegebene Parameter gesteuert (Kommandozeilenparameter). Ein Kommandozeilenprogramm läuft typischerweise mit den gegebenen Parametern einmal ab, bevor eine erneute Befehlseingabe möglich ist. Ein automatisiertes Abarbeiten mehrerer Kommandos nennt man Stapelverarbeitung (batch). In die Kommandozeile von RStudio können Variablendefinitionen, Berechnungen/Funktionen, sowie der Aufruf von Hilfefunktionen direkt eingegeben und ausgeführt werden. Die folgenden Beispiele zeigen die Auswirkungen von direkten Eingaben in der Konsole: 2 + 2 help(mean) ?mean Var1 &lt;- c(2,3,4) mean(Var1) Mathematische Operatoren/Funktionen Arithmetische und logische Operatoren in R sind in nachfolgender Tabelle definiert. Des weiteren findet man auszugsweise ein paar mathematische Funktionen, anhand deren das Prinzip eines Funktionsaufrufes verdeutlicht werden. Funktionen haben in R folgende Eigenschaften: jede Funktion hat einen Namen (z.B. sin für die Sinusfunktion, aov für Fit an Analysis of Variance Model, …) eine Funktion kann unter Umständen ohne Parameter (z.B. getwd()), oder mit einem oder mehrerern Parametern aufgerufen werden (z.B. mean(x), mean(x, na.rm = TRUE). Für Funktionen, bei denen die Übergabe von Parametern notwendig ist (z.B. mean()), ist folgendes zu beachten (gib in der Console den Befehl ?mean ein - beachte das Help-Fenster). In Klammern stehende Parameter die keine Bezeichnung aufweisen (bei der Funktion mean das x), sind zwingende Angaben für den Aufruf der Funktion. Bei Parametern, die mit einem Namen versehen sind, handelt es sich um optionale Parameter. Diese müssen beim Aufruf der Funktion nicht angegeben werden. In diesem Fall werden die in der Hilfe ersichtlichen Standardwerte verwendet. Sollten die Standardwerte nicht verwendet werden, sind diese beim Aufruf der Funktion mit entsprechenden Werten zu versehen - wie z.B. bei mean(x, trim = .2, na.rm = TRUE). Wird die Reihenfolge laut Beschreibung der Funktion in der Hilfeseite eingehalten, können die Namen der Parameter weggelassen werden. Kopiere bitte zeilenweise den nachfolgenden Code in die Konsole und diskutieren die Ergebnisse. x &lt;- c(rpois(n = 50, lambda = 10), 100, NA, NA) hist(x) mean(x) mean(x, na.rm = TRUE) mean(x, na.rm = TRUE, trim = .1) mean(x, TRUE, .1) mean(x, .1, TRUE) Tabelle 1: Operatoren und Funktionen Hilfe in RStudio Mit der Installation von RStudio wird automatisch auch eine Dokumentation der verfügbaren Funktionen zur Verfügung gestellt. Dieses Hilfe-System kann auf unterschiedlichste Arten angesprochen werden. Folgende Möglichkeiten sind im RStudio gegeben: über die Console mit folgenden Befehlen help.search(&quot;mean&quot;) help(&quot;mean&quot;) ?mean über das Help-Menü über das Files-Pane im Reiter Help Darüber hinaus gibt es noch die Möglichkeit, eine der unzähligen Helpseiten im Internet in Anspruch zu nehmen. Eine Empfehlung, welche Hilfeseite(n) am besten sind ist schwer zu geben - durch Erfahrung und persönlichen Vorlieben werden sich schnell ein paar Seiten als hilfreich bewähren. Zum Einstieg nachfolgend ein paar Seiten die ich persönlich immer wieder verwende: R-project Cookbook for R Quick-R RDocumentation RStudio Support u.v.m. Online-Lernprogramme Eine weitere (unerschöpfliche) Quelle um R effizient und schnell zu erlernen sind entsprechende Online-Kurse. Einerseits gibt es über YouTube bereits viele Tutorials (die mehr oder weniger hilfreich sind/sein können). Andererseits haben sich aber bereits einige Universitäten und Firmen darauf spezialisiert, qualitativ hochwertige Online-Tutorials und Webinars zur Verfügung zu stellen. Viele davon sind noch kostenlos. Auch hier ist es schwierig eine punktuelle Empfehlung abzugeben. Nachfolgend eine kurze (und daher sicher unvollständige) Liste von Anbietern, die ich zumindest zum Teil selbst ausprobiert und als gut empfunden habe: DataCamp. coursera. RStudio Online Learning. Course. Quick-R Tutorials. Verwendung der Konsole (Aufgabe 1) Berechne in der Konsole die Ergebnisse folgender Ausdrücke und prüfe das Ergebnis auf Korrektheit: \\((3 + 4 - 5) * 9\\) \\(\\frac{99}{33}\\) \\((\\sqrt{2})^2\\) \\(e^{3+4}\\) Gib nachfolgende Befehle ein und diskutiere das Ergebnis: \\(5 = 7\\) \\(5 == 7\\) \\(5*5 &gt;= 6*4\\) \\(\\sqrt{3} \\neq cos(17)\\) Die Lösungen zu den Beispielen findest du am Ende dieses Dokumentes. Wiederverwendung von Befehlszeilen - die Command-History Durch die Verwendung der Pfeiltasten (\\(\\uparrow\\) und \\(\\downarrow\\)) können Sie bereits eingegeben Befehle in der Kommandozeile aus der Historie abrufen. Die Historie ist auch über das Environment Fenster im Tab History verfügbar. Durch Markieren einzelner oder mehrerer Zeilen im History-Fenster und anschließender Eingabetaste, werden diese Befehle in die Kommandozeile übernommen und können dort nochmals ausgeführt werden. Weitere Eigenschaften der Console Pane Neben der Ausgabe von Ergebnissen werden in der Console-Pane auch Hinweise, Warnungen und Fehler die während der Ausführung eines Programmes, bzw. dem Laden/Aktualisieren von Packages ausgegeben werden angezeigt. Dabei ist vor allem bei den Meldungen, die während des Ladens/Aktualisierens von Packages angezeigt werden, besondere Aufmerksamkeit angebracht. Alle Meldungen, also rein informative wie auch Fehlermeldungen, werden in \\(\\color{red}{\\text{rot}}\\) angezeigt. Da häufig sehr viele Meldungen (sehr schnell) über die Console laufen, übersieht man leicht Fehlermeldungen. Daher ist es vor allem bei langen Meldungen zu empfehlen, die Gesamte Meldungsliste sorgfältig zu kontrollieren. Terminal-Fenster Das Terminalfenster bietet die Möglichkeit, direkt auf die Systemumgebung zuzugreifen. über die Systemumgebung kann man z.B.: Fernzugriffe (remote logins) ausführen. lang dauernde Berechnungen im Hintergrund starten. Fortgeschrittene Programmkontrolle starten. Administration eines RStudio-Servers durchführen. etc. R-Markdown-Fenster R-Markdown Beschreibung ist eine vereinfachte Auszeichnungssprache, mit dem Ziel Dokumente zu erstellen, in dem sowohl Text, wie auch R-Code sein kann. Markdown ist eng an HTML angelehnt, aber bei weitem kein Ersatz dafür. Wesentliche Vorteile von Markdown sind: Sehr leicht erlernbar. Forschung wird reproduzierbar. Leichterer Austausch von Analyseergebnissen und der zugehörigen Dokumentation. Beim Erstellen (“knit”) wird der Code ausgeführt und mit den Beschreibungen zusammen angezeigt. Das kombinierte Dokument kann als Word-, HTML- oder PDF-Datei erstellt. Neben der Nutzung als Software-Dokumentationswerkzeug bietet Markdown auch eine einfache Möglichkeit, einen Forschungsprozess durchgehend abzubilden und Inhalte mit fortlaufender Evaluierung während der Datenerhebung zu verbinden (Stichwort sanity-check). Ein Beispiel für die Nutzung von Markdown sind sämtliche Unterlagen dieser LV! Lösungen Aufgabe 1 rm(list = ls()) if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) pacman::p_load(here) # Berechnungen (3 + 4 + 5) * 9 99 / 33 sqrt(2)^2 exp(3+4) # Logische Vergleiche 5 = 7 5 == 7 5*5 &gt;= 6*4 sqrt(3) != cos(17) RStudio Beschreibung Wikipedia↩ Integrated Development Environment↩ "],
["source-pane.html", "3 Source-Pane Dateitypen Nützliches im Editor Running Code Traceback (Debugging) Kommentare", " 3 Source-Pane Der Source-Pane, oder auch Editor, ist ein äußerst hilfreiches Instrument bei der Erstellung von Programmen. Im Gegensatz zur Konsole ist es im Editor möglich, mehrere Befehle hintereinander aufzuzeichnen und diese dann nach Wunsch einzeln, blockweise oder gesamt auszuführen. Da in den meisten Füllen die Analyse von Daten aus mehreren/vielen hintereinander folgenden Arbeitsschritten (laden der Daten, Berechnung der deskriptiven Statistik, Erstellung von Graphen, inferenzstatistische Auswertung, etc.), ist die Programmierung ohne Editor undenkbar. Der mit RStudio zur Verfügung gestellte Editor hat neben der Möglichkeit Programmcode aufzuzeichnen und zu speichern eine Fälle weiterer Möglichkeiten. Die wichtigsten Eigenschaften für einen Start in die R-Programmierung werden in den folgenden Kapiteln kurz angesprochen. Dateitypen Der Editor bietet für die Erstellung von Dokumenten verschiedene Fiel-typen an: Abbildung 8: Dateitypen R R Script Das meist verwendete und für den Einstieg wesentliche Dokument ist das R Script. Geöffnete wird ein leeres Arbeitsblatt in welchem zeilenweise die Befehle und Funktionen von R eingefügt werden. Der Editor bietet aber darüber hinaus eine Vielzahl an weiterer Möglichkeiten, wie z.B.: Code-Complete Funktion Keyboard Shortcuts Code Snippets Extract Funktion Suchfunktionen Code Ausführung Traceback und Debugging Kommentare und Dokumentation von Code, oder Codeteilen Anwendung und Eigenschaften dieser Möglichkeiten werden im folgenden besprochen. R-Markdown R-Markdown ist eine Dokumentenart, mit der Textverarbeitung mit gleichzeitiger Nutzung aller R-Funktionalitäten vereint werden. Besondere Erwähnung findet es hier deshalb, da alle zur Verfügung stehenden Unterlagen dieses Kurses mit R-Markdown erstellt wurden. Sofern es zeitlich möglich ist, werden wir am Ende der Lehrveranstaltung die Verwendung und Anwendbarkeit dieser Option besprechen. Andere Dokumentenarten Die restlichen Arten von Dokumenten sind spezielle Formate, die eine Einbindung von C++ und diversen Dokumentationsformaten erlauben. Zu erwähnen wäre in diesem Zusammenhang noch die Shiny Web App, mit welcher man relativ einfach Benutzerschnittstellen (UI’s7) erzeugen kann. Diese Schnittstelle ist vor allem dann von Vorteil, wenn bestimmte Programme auch für Nutzer die keinen R-Background haben zur Verfügung gestellt werden. Nützliches im Editor Im folgenden beschäftigen wir uns kurz mit einigen der hilfreichsten Eigenschaften des RStudio-Editors. Code completion Unter code completion versteht man die Eigenschaft des Editors, während der Eingabe einer Funktions-, bzw. Variablennamens eine Liste der verfügbaren Funktionen/Variablen anzuzeigen und diese auch mit dem Tabulatur (\\(\\rightleftharpoons\\)) zu übernehmen. Nach wie vielen Zeichen die Liste angezeigt wird, kann über die Global Options im Menü Tools eingestellt werden (standardmäßig wird nach 3 Zeichen die Liste angezeigt). Abbildung 9: Einstellungen code completion im Menü Tools \\(\\rightarrow\\) Global Options \\(\\rightarrow\\) Code \\(\\rightarrow\\) Completion Öffne eine neue R Script Datei. Kopiere die erste Zeile des nachfolgenden Codes in das Skript und führe diese aus (markieren der Zeile mit anschließendem Drücken von Ctrl Enter). Gib nun die weiteren Befehlszeilen direkt in den Editor ein und beobachte den Effekt, der sich nach der Eingabe des dritten Zeichens zeigt. Keyboard Short-Cuts Mit Hilfe der Keyboard-Shortcuts können Zeichen, Funktionen, etc. schnell und einfach in das Skript eingefügt werden. Mit der Basisinstallation wurden bereits eine Menge von Shortcuts definiert. Eine Liste dieser Shortcuts ist durch den Shortcut Alt Shift K, oder unter folgendem Menü zu finden: Abbildung 10: Shortcut Liste (Alt Shift K) und Änderungsmöglichkeiten für Shortcuts (Tools \\(\\rightarrow\\) Global Options \\(\\rightarrow\\) Code \\(\\rightarrow\\) Editing) Welche der Shortcuts man sich wirklich merken soll ist Geschmacksache. Zwei sehr häufig von mir verwendete wären: Kommentar mit Ctrl Shift C Lange Zeilen besser darstellen mit Ctrl Shift /, etc. Code Snippets Neben den Shortcuts bieten auch die Snippets eine bedeutende Erleichterung beim Schreiben von Codes. Dabei handelt es sich um Textmakros die häufig verwendete Codefragmente in das Skript einfügen können. Vordefinierte Snippets können unter Tools \\(\\rightarrow\\) Global Options \\(\\rightarrow\\) Code \\(\\rightarrow\\) Edit angesehen und auch geändert, bzw. hinzugefügt werden. Abbildung 11: Snippets Definition und Änderungsmöglichkeiten (Tools \\(\\rightarrow\\) Global Options \\(\\rightarrow\\) Code \\(\\rightarrow\\) Edit Snippets) Wie bei der code completion werden nach 3 eingegebenen Zeichen die vordefinierten Snippets in einer Liste angezeigt. Die Übernahme des Inhalts wird durch Auswahl gefolgt vom Tabulator (\\(\\rightleftharpoons\\)) durchgeführt. Wird z.B. fun eingegeben, wird automatisch folgende Liste angezeigt: Abbildung 12: Snippets Definition und Anderungsmöglichkeiten (Tools \\(\\rightarrow\\) Global Options \\(\\rightarrow\\) Code \\(\\rightarrow\\) Edit Snippets) Durch Wahl der entsprechenden Funktion (in diesem Fall das Snippet), wird das Makro ausgeführt und der vordefinierte Text in den Editor eingefügt. Probier es am besten selbst aus. Gib fun ein, wähle das snippet fun und drücke die Tabulatortaste. Diskutiere das Ergebnis. Extract Funktion Die extract function wird vor allem dann verwendet, wenn ein selbst geschriebener Codeteil in eine Funktion umgewandelt werden soll. Die Vorgehensweise ist dabei denkbar einfach: schreibe einen Code. markiere den Code. wähle im Menü \\(\\rightarrow\\) Code \\(\\rightarrow\\) Extract Function, oder drücke Ctrl Alt X. Bennen die Funktion. Kopier die folgenden Zeilen in den Editor und wandle die Zeile: x - mean(x) in eine Funktion mit dem Namen center um. x / sd(x) in eine Funktion mit dem Namen rescale um. rescale(center(x)) in eine Funktion mit dem Namen standardize um. Markiere die drei Funktionen sowie die Zeilen x &lt;- 1:10 und standardize(x) und drücke Ctrl Enter Diskutiere das Ergebnis. Wenn alles funktioniert hat, sollte dein Code folgendermaßen aussehen: Suchfunktionen Häufig werden wir nach bestimmten Begriffen (Funktionsnamen, Variablennamen, etc.) innerhalb unseres Codes suchen. Mit Ctrl f, bzw. über das Menü Edit \\(\\rightarrow\\) Find, wird das zur einfachsten Sache - beachte das Suchfeld direkt unter der Symbolleiste, sowie die Möglichkeiten für die Einschränkung der Suche (In selection, Match case, etc.). Gleichzeitig wird damit auch die Möglichkeit gegeben, bestimmte Suchbegriffe im Text zu ersetzen (siehe Replace Feld). Abbildung 13: Suchen und Ersetzen im geöffneten Script Eine überaus wertvolle Suchfunktion kann durch Ctrl Shift f, bzw. über das Menü Edit \\(\\rightarrow\\) Find in Files, aufgerufen werden. Mit dieser Suchfunktion werden alle Files eines bestimmten Verzeichnisses auf bestimmte Begriffe durchsucht. Code Folding Mit code folding kann man vor allem bei längeren Programmen sehr gut die Übersicht von bestimmten Programmteilen behalten. Als Beispiel kann man den soeben erzeugten Code nochmals genauer betrachten: Abbildung 14: Code Folding Bei genauerem Hinsehen fallen einem vielleicht die schwarzen Dreiecke direkt neben der Zeilennummerierung auf. Klickt man diese mit der Maus an, wird entweder ein Teil des Codes auf eine Zeile reduziert (folding), oder falls bereits reduziert, wieder entfaltet. Anwendung findet diese Möglichkeit vor allem bei Codeteilen, die bereits getestet wurden und deren Einzelheiten für die weitere Entwicklung von Code nicht von Interesse sind. Damit wird unwesentliche ausgeblendet und die Übersicht über den relevanten Code leichter behalten. Running Code Für die zeilenweise Ausführung von Code brauch man nur in der betroffenen Zeile Ctrl Enter drücken (die Zeile kann, aber muss dafür nicht markiert sein). Wir die Markierung verwendet, ist darauf zu achten, dass genau der markierte Inhalt ausgeführt wird! Der Vorteil der Markierung liegt darin, dass nicht nur eine Zeile, sondern markierte Bereiche (Blöcke) ausgeführt werden können. Darüber hinaus bieten sich im RStudio die Symbolleisten für die Ausführung von Code an: Abbildung 15: Code Folding Traceback (Debugging) Eine wirklich geniale Sache bei RStudio ist die integrierte Möglichkeit des sogenannten Debugging. Um Debugging zu demonstrieren, verwenden wir den Codeteil aus dem Kapitel extract function. Bitte den nachfolgend gezeigten Code in ein neues RScript kopieren. Abbildung 16: Debugging in R Führe nun folgende Schritte aus: Speichere den neuen Code unter den Namen 03_DebuggingDemo.R. Ändere in der Funktion center mean(x) auf meen(x) (wir fügen absichtlich einen Fehler ein!) Speichere das Skript und führe es aus (mit Source in der Symbolleiste) Abbildung 17: Traceback in RStudio Kommentare Ein gutes, nachvollziehbares und wiederverwendbares R-Programm basiert nicht alleine auf einer effiziente Programmierung, sondern auch auf einer entsprechende Beschreibung des Programms, bzw. bestimmten Teilen des Programmcodes. Um ein Programm zu dokumentieren gelten folgende Regeln: Kommentare beginnen mit \\(\\#\\). Kommentare enden mit dem Ende der Zeile. Kommentare können am: Anfang einer Zeile stehen: \\(\\#\\) Erstellungsdatum: 12.11.2018 Nach einem Codeteil: mean(x) \\(\\#\\) Berechnung des Mittelwertes von x Sehr lange Kommentare in einer Zeile können durch der Bildschirmbreite angepasst werden. Einige Richtlinien für Kommentare in R findet ihr unter Commenting guidelines User Interfaces↩ "],
["environment-pane.html", "4 Environment-Pane History Connections", " 4 Environment-Pane Im R-Arbeitsbereich (environment) besteht aus allen Datenobjekten, die während einer R-Sitzung erstellt oder geladen werden. Das Environment ist sozusagen das Arbeitsgedächtnis von R. Beim Beenden von R wird man aufgefordert, den Arbeitsbereich zu speichern. Wählt man Ja, speichert R eine Datei mit dem Namen .RData in das aktuelle Arbeitsverzeichnis. Beim erneuten öffnen von R wird diese gespeicherte .RData wieder geladen. Dadurch sind alle Datenobjekte der letzten Sitzung in R wieder verfügbar. Auch auf alle in der letzten Sitzung eingegebenen Befehle können mit den Aufwärts- und Abwärtspfeiltasten (\\(\\uparrow\\), \\(\\downarrow\\)) der Tastatur zugegriffen werden. Speichern, laden, oder löschen des Arbeitsbereich kann auch jederzeit während einer R-Sitzung über das Menü, oder durch die entsprechenden Schaltflächen im Environment-Pane durchführt werden. Das Löschen bestimmter Objekte, bzw. des gesamten Environments ist auch von der Konsole, bzw. vom Skript durch folgende Funktionen möglich: a &lt;- 1:100 b &lt;- c(&quot;Salzburg&quot;, &quot;Wien&quot;, &quot;Linz&quot;) Seminar &lt;- &quot;R-Intro&quot; V1 &lt;- 1:10 M1 &lt;- matrix(1, 3, 3) M2 &lt;- matrix(5, 8, 3) center &lt;- function(x) {mean(x) - sd(x)} rm(a) # löscht die Variable a rm(V1, M1) # löscht die Variablen V1 und M1 rm(list = ls()) # löscht den gesamten Inhalt des Globalen Environments Am rechten Rand der Symbolleiste kann man noch die Ansicht der Objekte wählen: List: gibt nur die Namen der aktiven Objekte an. Grid: zeigt neben dem Namen auch den Variablentyp (Type), die Länge der Variablen (Length), die Größer (Size) und die ersten paar Werte im jeweiligen Objekts. Grid ist die zu bevorzugende Darstellungsform des Environments. Abbildung 18: Das Arbeitsgedächtnis von RStudio Bemerkenswert ist noch das Symbol Global Environment. Neben dem Global Environment gibt es für jedes der geladenen Pakete einen eigenen Arbeitsbereich, in welchem folgende Daten abgespeichert sind: die Funktionen des jeweiligen Paketes, sowie Datensätze die zur Testung der jeweiligen Funktion verwendet werden können History Die R-Verlaufsdatei (History) ist eine Kopie aller Tastenanschläge während einer Sitzung. Ein Rückgriff auf diese Verlaufsdatei kann vor allem dann nützlich sein, wenn nicht alle Schritte in einer R-Skriptdatei dokumentiert wurden. Die Rhistory-Datei ist eine einfache Textdatei, in der alle Befehle, aber nicht die Ergebnisse aufgezeichnet werden. Abbildung 19: Die Historie von verwendeten Befehlen Beachte die Symbole in dieser Ansicht. Man kann über diese: eine gespeicherte Historie von Befehlen laden. die aktuelle Historie speichern. Markierte Zeilen oder Blöcke der Historie an die Konsole senden und ausführen lassen (To Console). Markierte Zeilen oder Blöcke der Historie an die Source - also in ein geöffnetes R-Script - senden (To Source). markierte Einträge der Historie löschen. die gesamte Historie löschen. Connections Im RStudio-Verbindungsbereich (Connections) können Verbindung zu einer Vielzahl von Datenquellen hergestellt werden8. Vorwiegend verwendet wird es für die Anbindung diverser Datenbanken. Ohne Installation von Zusatzpaketen sind derzeit folgenden Datenbankverbindungen9 möglich: Abbildung 20: Datenbankverbindungen über Connections es ist jedoch kein Verbindungsmanager, wie z.B. PGAdmin, Toad oder SSMS.↩ ODBC, Spark↩ "],
["files-pane.html", "5 Files-Pane Files Plots Packages Help Viewer", " 5 Files-Pane Über das Files-Pane können 5 unterschiedliche Registerkarte angesprochen werden: Files Plots Packages Help Viewer Files Entspricht im Wesentlichen einem Dateimanager. Angezeigt werden die Inhalte des aktuellen Arbeitsverzeichnis, welches direkt unter den Symbolen angezeigt wird. Man kann das Arbeitsverzeichnis auch in der Konsole mit der Funktion getwd() abfragen und gegebenenfalls auch in eine Variable zur weitern Verwendung in einer Variablen speichern (siehe nachfolgende Beispiele). getwd() # gibt das aktuelle Arbeitsverzeichnis in der Konsole aus WD &lt;- getwd() # speichert das Arbeitsverzeichnis in der Variablen WD setwd(&quot;E:/OwnCloud/LEHRE2019/18WS R-Intro&quot;) setwd(WD) # setzt das Arbeitsverzeichnis entsprechend des Inhaltes # der Variable WD Plots Standardmäßig werden alle in R-erzeugten Plots in dieses Fenster geschrieben. über die Symbolleiste ist es möglich, zwischen den bereits generierten Plots zu blättern (\\(\\leftarrow\\), \\(\\rightarrow\\)), einen Plot in einem eigenen Fenster zu öffnen (Zoom), die Graphiken zu exportieren (als PDF oder als Bild in den verschiedensten Formaten, wie z.B. png, jpg, eps, tiff, etc.), einzelne Graphen, bzw. alle Graphen zu löschen. Abbildung 21: Das Ausgabefenster für Graphiken und Bilder Packages Eine zentrale Rolle bei der Verwendung von R spielen die Pakete. Im diesem Fenster kann man einerseits die bereits geladenen Pakete sehen, bzw. einen Update durchführen. Mit Packrat steuert man bei Projektarbeiten eine einheitliche Verwendung von Paketversionen für allen beteiligten Projektmitarbeitern. Abbildung 22: Pakete - der Motor von R Umgang mit Paketen Pakete sind Sammlungen zusätzlicher Funktionen, die bei Bedarf geladen werden können. Sie enthalten häufig Beispieldaten, die zur Demonstration dieser Funktionen verwendet werden können. Obwohl R in der Basisversion schon mit einigen gängigen statistischen Funktionen und Modellen ausgestattet ist, erfordern die meisten unserer Arbeiten zusätzliche Pakete. Installation und Verwendung von Paketen Um ein Paket verwenden zu können, muss es zuerst installiert und dann geladen. Diese Schritte können in der Befehlszeile oder auf der Registerkarte “Pakete” ausgeführt werden. Im Fenster “Pakete” sieht man eine Liste aller derzeit auf Ihrem Computer installierten Pakete sowie 2 Schaltflächen mit der Bezeichnung “Install” oder “Update”. Um ein neues Paket zu installieren, klickt man einfach auf die Schaltfläche Install. Für die Arbeit mit Pakten ist folgendes zu beachten: R-Pakete müssen nur einmal installiert werden (bis R aktualisiert oder neu installiert wird). Abbildung 23: Laden von Paketen Bei jedem Start einer neuen R-Sitzung muss jedoch jedes Paket, dass in der aktuellen Sitzung verwendet werden soll, geladen werden. Abbildung 24: Verwenden von Paketen In der Abbildung sind auch die Funktionen zum Installieren und Aktualisieren angegeben. Da bei vielen Paketen fortlaufend Änderungen/Erweiterungen und Verbesserungen vorgenommen werden, ist in regelmäßigen Abständen nach Updates der geladenen Pakete zu suchen. Dies ist am einfachsten über das Menü Tools \\(\\rightarrow\\) Check for Package Updates, bzw. über die Funktion update_packages() (ist im Package utils enthalten) in der Konsole oder über den Editor durchzuführen. Help Verschiedenen Möglichkeiten in R Hilfe in Anspruch zu nehmen, haben wir ja bereits in vorangegangenen Kapiteln angesprochen. Die unter dieser Registrierkarte befindliche Hilfe zu den einzelnen Funktionen ist in technischer Sicht sehr aufschlussreich, da es einer vollständigen Dokumentation der Funktionen innerhalb von Paketen entspricht. Für Einsteiger in R kann diese Hilfe jedoch auch schnell zu technisch werden. Daher empfiehlt es sich, bei Bedarf auf die bereits hingewiesenen Alternativen von benutzerfreundlicheren Websites zurückzugreifen. Viewer RStudio enthält einen Viewer-Bereich, in dem lokaler Webinhalt angezeigt werden kann. Beispielsweise Webgrafiken, die mit Paketen wie googleVis, htmlwidgets und rCharts generiert wurden, oder lokale Webanwendung, die mit Shiny, Rook oder OpenCPU erstellt wurde. Zu beachten ist, dass der Viewer-Bereich nur für lokale Webinhalte verwendet werden kann. Bei den Inhalten kann es sich entweder um statische HTML-Dateien handeln, oder um eine lokal ausgeführte Webanwendung handeln. Für die aktuelle Lehrveranstaltung wird dieses Fenster keine, bzw. nur eine nachrangige Rolle spielen, daher verzichten wir fürs Erste auf weitere Ausführungen zu diesen Themen. "],
["rlernen.html", "6 Rlernen Top-Down vs. Bottom-Up Objekte in R (bottom up) Faktoren Matrizen Data-Frames Data-Tables Listen Tables Attribute Lösungen", " 6 Rlernen Top-Down vs. Bottom-Up Wie beim Erlernen einer neuen Sprache, gibt es auch für Programmiersprachen verschiedene Ansätze. Im Bottom-Up Ansatz wird man sich zuerst mit den Elementen einer Sprache (Vokabeln) und deren korrekter Zusammensetzung (Grammatik) beschäftigen. Dieser Ansatz ist vor allem zu Beginn oft schwierig und mühsam, da die Zusammenhänge erst nach einiger Zeit klar werden und die (erfolgreiche) Anwendung der Sprache erst nach einer mehr oder weniger langen Vorlaufzeit möglich ist. Beim Top-Down Ansatz wird man direkt mit dem gesamten Umfang der Sprache konfrontiert. Sprachbausteine werden von anderen übernommen, Details zur Struktur, den Regeln und eine Erweiterung des Wortschatzes bilden sich durch die Übernahme von Experten. Bei der Erlernung einer Programmiersprache bietet sich vor allem durch die unzähligen Möglichkeiten von Beispielen und Vorlagen im Internet, sowie die bis ins letzte Detail ausgearbeiteten Hilfeseiten zu den jeweiligen Sprachen eine Mischung des Lernvorganges an. Wir werden den Einstieg in die Programmiersprache R mit einem Top-Down Ansatz beginnen. Top Down - Copy und Paste Erstelle eine neue R-Script-Datei. Kopiere den nachfolgenden Code in diese neue Datei und speicher diesen unter den Namen 06_R_Paste_Copy_Intro.R in ein Verzeichnis deiner Wahl. #------------------------------- Initialisierung rm(list = ls()) if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) pacman::p_load(ggplot2) #------------------------------- Ende Initialisierung Öffne einen Browser (Mozilla, IE, Chrome, …) und bearbeite folgende Aufgabenstellungen: Copy und Paste (Aufgabenblock) Kopiere von Indexing with numbers and names die Zeile \\(v &lt;- c(1,4,4,3,2,2,3)\\) in das neue Skript und führe diese Zeile aus. Beschreibe die Auswirkung dieser Zeile bezüglich der Änderungen im Konsolen- und Environment-Fenster. Kopiere (aus der Website) die Zeile \\(v[c(2,3,4)]\\) in das neue Skript und führe diese Zeile aus. Beschreibe die Auswirkung dieser Zeile bezüglich der Änderungen im Konsolen- und Environment-Fenster. Gehe zur folgenden Website: Bar and line graphs (ggplot2) und kopiere aus dem Block Bar graphs of values die ersten vier Zeilen in den Editor. Führe diese Zeilen aus und diskutiere das Ergebnis. Kopiere nun von dieser Website den zweiten Codeblock und führe den Code aus. Diskutiere das Ergebnis (siehe Plots-Fenster). Kopiere nun die zwei Codeblocks im Kapitel “Bar graphs of counts” und führe den Code aus. Beachte vor allem, woher die Daten (tips) kommen! Gebe die Befehle data() und ?tips, bzw. ?french_fries ein und diskutiere das Ergebnis. Führe folgende zwei Zeilen aus: Dat_FF &lt;- french_fries str(Dat_FF) Laden mit Hilfe von Import Dataset die SPSS-Datei “bigfive.sav” und kopiere die entsprechenden Befehle in dein Skript. Lade nun die Datei “bigfive_excel.xlsx” (ebenfalls in ../Data/) mit Hilfe von Import Dataset und kopiere die entsprechenden R-Befehle in den Editor. Objekte in R (bottom up) In R kann alles als Objekt gespeichert werden. Einzelne Werte Mehrere Werte (z. B. als Datensatz mit Rohdaten) Tabellen Statistische Modelle Ergebnisse statistischer Analysen Funktionen, etc. Alle Objekte, die in einer R-Sitzung erstellt oder geöffnet wurden, liegen im sogenannten Environment (Arbeitsbereich). Bei der letzten Übungsaufgabe wurden folgende Objekte im Environment angelegt: Abbildung 25: Environment der letzten Übungsaufgabe Das Anlegen eines Objektes im Environment erfolgt über die Zuweisung Objektname &lt;- Objektinhalt. Die Zuweisung über das &lt;- ist dabei R-spezifisch. Man kann auch das übliche = verwenden, wobei dieses in R auch noch eine andere Eigenschaft hat (Details später). Für die Vergabe von Objektnamen sind folgende Regeln zu beachten: Objektname darf nicht mit Zahl beginnen Objektname darf keine Operatoren enthalten (+, -, * etc.) Auf Groß- und Kleinschreibung achten In gibt es eine Vielzahl von verschiedenen Objekttypen. Die grundlegenden Objekttypen (und deren Gemeinsamkeit mit SPSS-Datentypen) sind: Vektoren \\(\\rightarrow\\) ordinale/metrische Variablen numeric (Zahlen) character (Buchstaben) Faktoren \\(\\rightarrow\\) nominale/ordinale Variablen nominale Variable Kategorien des Faktors = levels (kann Buchstaben oder Zahlen enthalten) Data Frames (mehrere Zeilen und Spalten) \\(\\rightarrow\\) Datensatz Spalten (Vektoren und Faktoren Zeilen (Fälle, z. B. Versuchspersonen) Matrizen \\(\\rightarrow\\) in SPSS nicht vorhanden viele Zeilen und Spalten es können nur Daten eines Typs (z. B. numerische Werte, oder nur Faktoren, etc.) dargestellt werden. Arrays \\(\\rightarrow\\) in SPSS nicht vorhanden Kombination mehrerer Matrizen (Zusammenfassungen von Elementen des gleichen Datentyps (numeric, character, logical), werden über 2 oder mehr Indizes adressiert). Listen \\(\\rightarrow\\) in SPSS nicht vorhanden Kombination mehrerer Objekte Listen können beliebige Objekte enthalten, auch Objekte verschiedenen Typs. Im Unterschied zu Data Frames und Arrays können auch Objekte unterschiedlicher Länge gespeichert werden. Vektoren Das einfachste Objekt ist ein Vektor, der aus mehreren Elementen besteht. Öffne eine neue Skript-Datei und kopiere folgenden Inhalte in diese Datei: name &lt;- &quot;Max Mustermann&quot; # Beachte das Fenster Environment mein.alter &lt;- 35 mein.alter mein.alter + 10 mein.alter.1 &lt;- mein.alter + 10 mein.alter.1 Speichere die Datei unter dem Namen 06_Objekte.R. Führe nun die Inhalte zeilenweise aus und diskutiere die Wirkung der einzelnen Zeilen! Kopiere nun den folgenden Code in die Datei und führe diesen Code zeilenweise aus. Was passiert dabei im Environment? # Fasse Zahlen in einem Vektor zusammen alter &lt;- c(19, 24, 20, 19) # Beispiel: Alter von 4 Studenten kurs.num &lt;- c(1, 3, 2, 2) # Beispiel: Zugeh?rigkeit zu einem von 3 Kursen # Fasse Buchstaben in einem Vektor zusammen kurs.bez &lt;- c(&#39;Kurs1&#39;, &#39;Kurs3&#39;, &#39;Kurs2&#39;, &#39;Kurs2&#39;) # Zeige Inhalt des Vektors alter kurs.num kurs.bez Um auf einzelne Elemente eines Vektors zuzugreifen gibt es mehrere Möglichkeiten. Zugriff durch direkte Indizierung Zugriff durch Variablen (Vektoren), in denen die Indizes der Elemente auf die man zugreifen will abgespeichert sind. Der folgende Code zeigt beide dieser Möglichkeiten. Kopiere den Code in das Skript und führe diesen zeilenweise aus. alter[2] # direkte Indizierung, das zweite Element des Vektors wird ausgegeben alter[1:3] # direkte Indizierung, das erste bis dritte Element des Vektors wird ausgegeben. # Beachte dabei die Verwendung von : 2:4 # erzeugen eines Vektors der in ganzen Schritten von 2 beginnend bis 4 hinaufz?hlt v_1 &lt;- 2:4 # speichern des Vektors in der Variablen v_1 alter[v_1] # Verwendung des Vektors v_ind um die Elemente des Vektors alter auszugeben v_2 &lt;- seq(from = 1, # erzeugen einer Sequenz von Zahlen, die mit 1 beginnt, bei 4 endet to = 4, # und in 2-er Schritten hinaufz?hlt by = 2) # Die Sequenz wird in v_2 gespeichert. alter[v_2] # Verwendung des Vektors v_2 um die Elemente des Vektors alter auszugeben. alter[-4] # um Werte eines Vektors nicht anzuzeigen, kann der Index des entsprechenden # Wertes mit einem f?hrenden Minuszeichen angegeben werden. Dadurch wird der # vierte Eintrag des Vektors nicht ausgegeben! v_3 &lt;- c(1, 3, 4) # auch die Verwendung der Funktion c() kann zur Erstellung von Indexlisten # verwendet werden. alter[v_3] Um festzustellen, um welche Art von Daten, bzw. welche Klasse von Daten (numerisch, alphanumerisch, Datum, etc.) im jeweiligen Objekt abgespeichert sind, kann die Funktion class() verwendet werden. Das Ändern des Datentyps eines (einfachen) Objektes ist durch die Funktionen as.numeric(variable), bzw. as.character(variable) möglich. Darüber hinaus gibt es noch viele Funktionen, die bezüglich des Datentyps von Objekten verwendet werden können. Einige dieser Funktionen werden bei den entsprechenden Anwendungen im Detail besprochen. class(alter) # Zeigt an, zu welcher Klasse die Inhalte des Objekts alter geh?ren alter_char &lt;- as.character(alter) # wandelt num in char class(alter_char) alter_num &lt;- as.numeric(alter_char) # wandelt char in num class(alter_num) Das Wandeln von numerisch auf alphanumerisch und vice versa sind jedoch häufig gebrauchte Funktionen, vor allem bei der Übernahme von Daten aus anderen Anwendungen. Arithmetische Operator (Vektorenrechnung) In R werden + - * / für Addition, Subtraktion, Multiplikation und Division verwendet. Diese Operatoren werden auf alle Elemente eines Vektors angewendet: Geburtsjahr &lt;- 2018 - alter Alter_Tage &lt;- alter * 365 v1 &lt;- 1:5 v2 &lt;- v1*2 v2 v2 &lt;- v2 - .5 v2 v3 &lt;- c(2, 5, 8, 10, 12) v4 &lt;- v1 * v3 Weitere nützliche Vektor-Funktionen Neben der bereits besprochenen Funktion seq(), sind auch nachfolgende Funktionen für das Arbeiten mit Vektoren oft nützlich. Da wir diese Funktionen laufend verwenden, werden hier nicht alle Einzelheiten diskutiert - verwende dazu die help() Funktion. y &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) rep(y, 3) # Replicate Elements of Vectors and Lists rep(1:5, 4) n &lt;- c(2, 4, 1, 10) rep(y, n) y &lt;- c(&quot;i&quot;, &quot;i&quot;, &quot;a&quot;, &quot;a&quot;, &quot;E&quot;, &quot;E&quot;, &quot;E&quot;, &quot;E&quot;, &quot;U&quot;) unique(y) # eindeutige Elemente eines Vektors table(y) # erstellt eine Kreuztabelle sort(y) # sortieren von Vektoren (ACHTUNG: order() bei Datenstrukturen verwenden, siehe sp?ter) paste(y, 1:9) paste0(y, 1:9) Logische Vektoren Ein logischer Vektor besteht aus TRUE und FALSE Elementen. Diese Vektoren folgen einer sogenannten Boolean-Logik mit diesen Prinzipien (in R wird das logische UND mit \\(\\&amp;\\), das logische ODER mit \\(|\\) geschrieben: T und T gleicht T (T &amp; T \\(\\rightarrow\\) T) F und F gleicht F (F &amp; F \\(\\rightarrow\\) F) T und F gleicht F (T &amp; F \\(\\rightarrow\\) F) T oder T gleicht T (T | T \\(\\rightarrow\\) T) F oder F gleicht F (T | T \\(\\rightarrow\\) F) T oder F gleicht T (T | T \\(\\rightarrow\\) T) Werden Klammern verwendet gilt: Ausdruck innerhalb der Klammern wird zuerst ausgewertet! Mit der sum() Funktion können die Anzahl der wahren (T) Elemente eine Vektors ermittelt werden. Ein Anwendungsbeispiel wäre z.B., mit einer logischen Abfrage zu ermitteln, wie viele Ja-Antworten in einem Vektor bestehend aus Ja/Nein Antworten vorhanden sind (siehe nachfolgenden Code). T &amp; T F &amp; F T &amp; F T | T F | F T | F (T &amp; F) | T Vec &lt;- c(rep( &quot;Nein&quot;, len = 25), rep( &quot;Ja&quot;, len = 43), rep( &quot;Weder noch&quot;, len = 12)) sum(Vec == &quot;Ja&quot;) Der %in% Operator und die which()-Funktion Der %in% Operator wird benutzt, um einem Vektor mehrere Elemente zu entnehmen. Dies kann auch mit sämtlichen Teilfragen und dem | Operator durchgeführt werden. Nachfolgend erzeugen wir einen logischen Vektor InVec, der T ist, wenn Vec “Nein” oder “Weder noch” enthält: InVec &lt;- Vec %in% c(&quot;Nein&quot;, &quot;Weder noch&quot;) InVec Logische Operatoren und die which() Funktion bieten eine effiziente Möglichkeit auf Elemente eines Vektors zuzugreifen. Betrachte folgende Beispiele: VRand &lt;- rnorm(200, mean = 50, sd = 8) VRand_GT_Mean_Indices &lt;- VRand &gt;= mean(VRand, na.rm = T) VRand[VRand_GT_Mean_Indices] sum(VRand_GT_Mean_Indices) sum(VRand_GT_Mean_Indices == &quot;TRUE&quot;) sum(VRand_GT_Mean_Indices != &quot;TRUE&quot;) any(VRand_GT_Mean_Indices) which(VRand_GT_Mean_Indices) which(VRand_GT_Mean_Indices == &quot;TRUE&quot;) which(VRand_GT_Mean_Indices == &quot;FALSE&quot;) Aufgabenblock Vektoren Kopiere den folgenden Code in eine neues R-Skript und speichere dieses unter dem Namen 06_Objekte_Aufgaben. # Vektoren - Combine id &lt;- c(11, 16, 17, 18, 19, 20, 23) # c() entspr. combine; &lt;- Zuweisung zu einer Variablen Geschlecht &lt;- c(&quot;m?nnlich&quot;, &quot;weiblich&quot;) sex &lt;- c(1, 1, 7, 1, 1, 2, 2) lalt &lt;- c(2, 3, 2, 3, 1, 1, 2) gross &lt;- c(173, 166, 178, 154, 164, 389, 181) mon &lt;- c(266, 241, 231, 265, 225, 229, 222) date &lt;- c(4, 5, 3, 3, 2, 4, 3) entsch &lt;- c(3, 4, 4, 5, 3, 1, 2) proj &lt;- c(2, 1, 2, 2, 2, 1, 2) i1 &lt;- c(3, 2, 1, 3, 4, 2, 2) i2 &lt;- c(3, 2, 1, 3, 4, 2, 2) i3 &lt;- c(3, 3, 3, 2, 2, 2, 4) i4 &lt;- c(2, 1, 2, 4, 2, 1, 4) i5 &lt;- c(2, 1, 4, 1, 3, 4, 1) Bearbeite nun folgende Aufgaben: berechne den Mittelwert der Variablen gross. kopiere die Variable gross in eine neue Variable gross1. ersetze den ersten Wert von gross1 mit dem Wert NA. berechne den Mittelwert von gross1 - diskutiere das Ergebnis. berechne den Mittelwert von gross1 unter Berücksichtigung fehlender Werte (verwende die Hilfe um über die Parameter der Funktion mean() nachzulesen!). berechne den Mittelwert von gross1, wobei 50% der Werte (je 25% der ersten und 25% der letzten) nicht in die Mittelwertberechnung einbezogen werden sollen. bilde das Produkt des zweiten mit dem dritten Wert der Variablen gross und speichern das Ergebnis in der Variablen gross_prod. setzte den dritten Wert der Variablen sex auf 1. erstelle eine Variable (x), deren Werte absteigend und in Einserschritten von 50 nach 1 sein sollen. zeige alle bis auf den zweiten Wert der Variablen x an. erstelle eine Sequenz (x) die mit 1 beginnt und in Zweierschritten hinaufzählt. erstelle eine Sequenz (x) die mit 10 beginnt und in Zweierschritten hinunterzählt. erstelle eine Sequenz (x) die mit 0 beginnt und in Zweierschritten bis 10 hinaufzählt und deren letzter Wert 50 ist (also x = 0 2 4 … 10 50). stelle fest, welcher Klasse der Vektor x zugeordnet ist. wandle den Vektor x vom Datentyp ‘numeric’ auf ‘character’ und speichere das Ergebnis in x_c. stelle fest, welcher Klasse der Vektor x_c zugeordnet ist. wandle den Vektor x zurück in Datentyp ‘numeric’ und speichere das Ergebnis in x_n stelle fest, welcher Klasse der Vektor x_n zugeordnet ist. wie viele Personen sind größer-gleich (\\(\\ge\\)) als 173? für welches Element der Variablen gross ist die Körpergröße = 181 wahr (T)? Faktoren Faktoren sind eine spezielle Form von Vektoren und werden auch in R als nominale Daten definiert. Beispielsweise wird die Unterteilung von Probanden nach dem Geschlecht üblicherweise in einem Datentyp Faktor abgespeichert. Dieser Faktor würde üblicherweise 2 sogenannte Faktorenstufen (levels) besitzen (männlich/weiblich). Faktoren können aber durchaus auch mehrere Faktorenstufen aufweisen. Zum Beispiel könnte ein Faktor die höchst abgeschlossene Schulbildung (Hauptschulabschluss, Abitur, FH, Uni) abbilden. Dieser Faktor hätte demnach 4 Stufen. Da Faktoren auf nominalen Niveau definiert werden, ist eine Zuordnung von levels und labels möglich. Für SPSS-Nutzer ist diese Möglichkeit etwas verwirrend, da die Bedeutung in R folgende ist: levels sind der Input, also wie die Stufen kodiert sind (im Beispiel mit 1, 2, 3). labels sind der Output, also welche levels mit welchem label versehen werden. Um mehrere Daten einem Faktor zuzuordnen, wird der factor()-Befehl mit dem c()-Befehl kombiniert. Kopiere folgenden Code in das Skriptfile und führe die Befehle zeilenweise aus. Diskutiere die Ergebnisse. # Fasse Zahlen in einem Vektor zusammen alter &lt;- c(19, 24, 20, 19) # Beispiel: Alter von 4 Studenten kurs.num &lt;- c(1, 3, 2, 2) # Beispiel: Zugeh?rigkeit zu einem von 3 Kursen # Fasse Buchstaben in einem Vektor zusammen kurs.bez &lt;- c(&#39;Kurs1&#39;, &#39;Kurs3&#39;, &#39;Kurs2&#39;, &#39;Kurs2&#39;) A &lt;- factor(c(&quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;male&quot;)) A levels(A) nlevels(A) kurs.fac1 &lt;- factor(kurs.num) class(kurs.fac1) kurs.fac2 &lt;- factor(kurs.num, levels = c(1, 2, 3), labels = c(&#39;Kurs1&#39;, &#39;Kurs2&#39;, &#39;Kurs3&#39;)) str(kurs.fac2) levels(kurs.fac2) table(kurs.fac2) Aufgabenblock Faktoren erstelle die Variable x = c(1,2,3,1,1,2,2) und wandeln diese in einen Faktor x_fact um. Benenne die Stufen des Faktors der Variablen x_fact mit ‘A’, ‘B’, … kopiere x_fact in Variable x_fact2 und ändere die Bezeichnung der Faktorenstufen auf ‘S1’, ‘S2’, … (verwenden dazu die Funktion levels(…)). Verwende den Befehl table() um die Variable x_fact2 anzuzeigen. Was bewirkt der Befehl? gib folgenden Befehl ein: x_fact3 = factor(x_fact2, levels = c(‘S3’, ‘S1’, ‘S2’)). Vergleiche x_fact2 und x_fact3, was hat sich geändert? Matrizen Matrizen sind in R Objekte, denen Elemente gleichen Datentyps in Form von Zeilen und Spalten zugewiesen können. Damit können Vektoren des gleichen Datentyps in ein Objekt (der Matrix) zeilen-, oder spaltenweise zusammengehängt und abgespeichert werden. In R kann eine Matrix aus Vektoren mit den rbind() und cbind() Funktionen zusammengesetzt werden. Mit rbind() werden die Vektoren als Reihen der Matrix gespeichert, und mit cbind() als Spalten. Werden Vektoren mit unterschiedlichen Datentypen durch diese Funktionen zusammengefasst, werden alle Werte in der Matrix als Typ character gespeichert. Kopiere den Code aus folgenden Block und führe diesen zeilenweise aus. Diskutiere die Ergebnisse. A &lt;- 1:10 B &lt;- sample(15:93, 10, replace = TRUE) C &lt;- rbind(A,B) # Zeilenweises zusammenfÃ¼hren der beiden Vektoren str(C) # Zeigt die Struktur und jeweiligen Datentypen in der Struktur von Matrix C matrix.col &lt;- cbind(A, B) # Spaltenweises zusammenf?hren der beiden Vektoren matrix.col colnames(matrix.col) &lt;- c(&quot;LNr&quot;, &quot;Alter&quot;) rownames(matrix.col) &lt;- paste0(&quot;VP&quot;, 1:10) matrix.col matrix.col.Alternativ &lt;- cbind(LNr = A, Alter = B) # sofortige Benennung der Variablen matrix.col.Alternativ matrix.rows &lt;- rbind(A, B) # Zeilenweises zusammenfÃ¼hren der beiden Vektoren matrix.rows AnzZeilen &lt;- nrow(matrix.rows) AnzSpalten &lt;- ncol(matrix.rows) DimMat &lt;- dim(matrix.rows) DimMat[1] # Anzahl Zeilen in der Matrix matrix.rows DimMat[2] # Anzahl Spalten in der Matrix matrix.rows Wie dem obigen Code zu entnehmen ist, kann bei einer Matrix sowohl der Spaltenname wie auch die Bezeichnung der Zeilen mit den Funktionen colnames() und rownames() festgelegt werden. Vor allem bei den Spaltenbezeichnungen erweist sich diese Möglichkeit für viele Anwendungen noch als sehr hilfreich. Um festzustellen, wie viele Zeilen, bzw. Spalten eine Matrix besitzt, kann man entweder dem Environment (Spalte Value) entnehmen, oder direkt mit den Funktionen nrow(Matrix) / ncol(Matrix) abfragen. Die Funktion dim(Matrix) liefert als Ergebnis einen Vektor, dessen erster Eintrag die Zeilenanzahl und der Zweite die Spaltenanzahl beinhaltet10. Zugriff auf Elemente einer Matrix Wie bereits bei Vektoren, wird auch bei Matrizen ein Index für die Adressierung einer Position verwendet. Im Unterschied zum Vektor, werden bei Matrizen zwei Indizes verwendet: der erste Index bezieht sich immer auf die Zeilennummer einer Matrix der zweite Index bezieht sich immer auf die Spaltennummer einer Matrix Folgende Beispiele verdeutlichen die Verwendungsmöglichkeiten der Adressierung mit Indizes: matrix.rows matrix.rows[2,] # liest alle Elemente der zweiten Zeile einer Matrix matrix.rows[,2] # liest alle Elemente der zweiten Spalte einer Matrix matrix.rows[1,2] # liest das Element der ersten Zeile und der zweiten Spalte einer Matrix matrix.rows[2,1] # liest das Element der zweiten Zeile und der ersten Spalte einer Matrix matrix.rows[1,3:4] # liest das Element der ersten Zeile und der dritten bis vierten Spalte einer Matrix ZI &lt;- 2 # Zeilenindex SI &lt;- c(1,3,4) # Spaltenindex matrix.rows[ZI,SI] # liest die ZI&#39;te Zeile(n) und die SI&#39;ten Spate(n) matrix.rows[3] # Gibt das dritte Element eine Matrix aus. Ausgehend von der ersten Zeile und Spalte, # werden die Elemente der ersten Spalte aufsteigend nummeriert. Am Ende einer Spalte, # wird die Nummerierung in der ersten Zeile der nachfolgenden Spalte fortgesetzt - # bis das Ende der Matrix erreicht ist. matrix.rows[6] Bemerkung: verwendet man bei einer Matrix nur einen Index, so wird das entsprechende Element eine Matrix ausgegeben. Die Nummerierung wird dabei folgendermaßen festgelegt: ausgehend von der ersten Zeile und Spalte werden die Elemente der ersten Spalte aufsteigend nummeriert. Am Ende einer Spalte wird die Nummerierung in der ersten Zeile der nachfolgenden Spalte fortgesetzt - bis das Ende der Matrix erreicht ist. Erzeugen von Matrizen Es gibt verschiedenstes Möglichkeiten, Matrizen mit Hilfe von R-Funktionen zu erzeugen. Vor allem für Simulation von Daten (z.B. Ziehung eines Samples der Größe \\(N\\) aus einer normalverteilten Grundgesamtheit, oder aus einer Gleichverteilung etc.) kann für die Evaluierung von statistischen Modellen elegant gelöst werden. Folgende Beispiele geben einen Einblick in einige wenige Möglichkeiten Matrizen zu generieren. Kopier den Code in deinen Editor und führe diesen zeilenweise aus. Diskutiere die Funktionen und die Ergebnisse. matrix(5, 3, 3) matrix( rep( 0, len = 25), nrow = 5) matrix(runif(9), 3, 3) a &lt;- sample(1:100, 9, replace = TRUE) matrix(a, 3, 3) b &lt;- rnorm(9, mean = 100, sd = 15) matrix(b, 3, 3) Arithmentische Funktionen auf zwei Matrizen Wenn arithmetische Funktionen auf zwei Matrizen angewendet, dann werden immer zwei Elemente derselben Zeile und Spalte addiert, subtrahiert, multipliziert oder dividiert. Aus diesem Grund ist es auch erforderlich, dass die Dimension (= Anzahl Zeilen und Spalten, auch \\(m \\times n\\)) der beiden Matrizen übereinstimmt. Dies kann mit Hilfe von logischen Operatoren überprüft werden. Ohne auf weitere Details einzugehen, sei hier noch die Berechnung des Skalarproduktes zweier Matrizen erwähnt. Dieses wird durch den Operator \\(\\%*\\%\\) berechnet. Kopier den folgenden Code in den Editor und führe diesen Zeilenweise aus. Diskutiere die Ergebnisse. R1 &lt;- rnorm(9, mean = 100, sd = 15) m1 &lt;- matrix(R1, 3, 3) R2 &lt;- rnorm(9, mean = 100, sd = 15) m2 &lt;- matrix(R2, 3, 3) dim(m1) == dim(m2) R3 &lt;- rnorm(12, mean = 100, sd = 15) m3 &lt;- matrix(R3, 4, 3) dim(m1) == dim(m3) m1 * m2 m1 - m2 m1 / m2 m4 &lt;- m1 %*% m2 # ACHTUNG: berechnet das Skalarprodukt! m4 m5 &lt;- m1[,1] %*% m2[,1] m5 Darüber hinaus können auch Funktionen wie mean(), median(), sum(), etc. auf alle Elemente einer Matrix angewendet werden. Kopier den folgenden Code in den Editor und führe diesen zeilenweise aus. Diskutiere die Ergebnisse. R6 &lt;- rnorm(24, mean = 100, sd = 15) m6 &lt;- matrix(R6, 8, 3) mean(m6) # Grand Average der Matrix m1 apply(m6, 1, mean) # Mittelwert der Zeilen apply(m6, 2, mean) # Mittelwert der Spalten Die hier verwendete Funktion apply() ist Teil einer Funktionsgruppe, die als Alternative für Schleifen verwendet werden kann. Weitere wichtige Funktionen dieser Gruppe sind: lapply() - Anwendung einer Funktion auf die Elemente einer Vektoren, Dataframes und Listen. Liefert als Ergebnis eine Liste. sapply() - vereinfacht die Ausgabe der lapply()-Funktion. rep() - zum wiederholten Replizieren von Vektoren und/oder Faktoren. Anwendung und Details über diese Funktionen werden in entsprechenden Kapiteln behandelt. Aufgabenblock Matrizen id &lt;- c(11, 16, 17, 18, 19, 20, 23) # c() entspr. combine; &lt;- Zuweisung zu einer Variablen Geschlecht &lt;- c(&quot;mÃ¤nnlich&quot;, &quot;weiblich&quot;) sex &lt;- c(1, 1, 7, 1, 1, 2, 2) lalt &lt;- c(2, 3, 2, 3, 1, 1, 2) gross &lt;- c(173, 166, 178, 154, 164, 389, 181) mon &lt;- c(266, 241, 231, 265, 225, 229, 222) date &lt;- c(4, 5, 3, 3, 2, 4, 3) entsch &lt;- c(3, 4, 4, 5, 3, 1, 2) proj &lt;- c(2, 1, 2, 2, 2, 1, 2) i1 &lt;- c(3, 2, 1, 3, 4, 2, 2) i2 &lt;- c(3, 2, 1, 3, 4, 2, 2) i3 &lt;- c(3, 3, 3, 2, 2, 2, 4) i4 &lt;- c(2, 1, 2, 4, 2, 1, 4) i5 &lt;- c(2, 1, 4, 1, 3, 4, 1) Unter Verwendung der obigen Variablen sind folgende Aufgaben zu bearbeiten: erstelle eine Matrix X, in welcher die Variablen lalt, sex und gross als Spalten gespeichert sind. erstelle eine Matrix Z, in welcher die Variablen lalt, sex und gross als Zeilen gespeichert sind. Gib den Wert der zweiten Zeile und dritten Spalte der Variablen X aus. Gib die dritte Zeile der Variablen X aus (alle Spalten). Gib die 3te bis 5te Zeile und 1te bis 2te Spalte der Variablen X aus. Verwende den Befehl colnames() um die Spaltenbezeichungen der Variablen X anzuzeigen. erstelle eine Variable ColNames mit den Werten ‘Alter’, ‘Gewicht’ und ‘Groesse’. weise der Variablen X diese neuen Spaltenbezeichungen zu (verwende den Befehl colnames()). erstelle eine Variable namen, in welcher 7 beliebige Namen gespeichert sind. verwende diese Variable um der Matrix X diese Namen als Zeilenbezeichnung zuzuweisen (verwenden den Befehl rownames()). probiere den Befehl fix(X), vgl. in der Hilfe, was der Befehl macht und diskutiere die Eigenschaften. ermittle die ‘Dimension’ der Matrix X (verwende den Befehl dim()). ermitteln die ‘Länge’ der Matrix X (verwende den Befehl length()). Berechne die Körpergröße in Meter und füge das Ergebnis als weitere Spalte zur bestehenden Matrix X an. Ermittle jene Positionen (Indizes) der Personen die größer als 200 cm sind. Was ist der Name der Person? Data-Frames Eine Erweiterung des Datentyps Matrix ist der sogenannte Dataframe. Mit diesem Datentyp ist es möglich, innerhalb eines Objektes auch unterschiedliche Formate (Datentypen) zu speichern. Bei Vektoren und Matrizen gilt die Einschränkung, dass alle Elemente denselben Datentyp aufweisen müssen. Bei Matrizen gilt darüber hinaus, dass beim Hinzufügen von z.B. einer weiteren Spalte die Anzahl der Zeilen der bereits bestehenden Zeilenanzahl der Matrix entspricht (anderenfalls gibt es eine Fehlermeldung). Bei einem Dataframe können nun Daten unterschiedlichen Typs in ein Objekt zusammengefasst werden. Allerdings bleibt die Voraussetzung, dass die Länge der unterschiedlichen Elemente (Vektoren) gleich ist. Ein Dataframe ist in gewisser Weise vergleichbar mit einer Excel-Tabelle. Abbildung 26: Beispiel für unterschiedliche Daten in einer Excel-Tabelle In der ersten und dritten Spalte (LNr, Alter) sind numerische Werte, in der zweiten ist ein Datum und in der vierten ein Name (String, Charakters). Wärde diese Tabelle in R als Matrix gespeichert, würde R alle Daten in den Datentyp character umwandeln! Bei einem Datenframe wird im Gegensatz dazu der Datentyp jeder Spalte beibehalten. Um aus bestehenden Objekten (Vektoren, Matrizen) einen Datenframe zu erstellen, wird die Funktion data.frame() benutzt. Der Zugriff auf die Elemente eines Dataframes ist gleich wie bei Matrizen. Der Name des Dataframes gefolgt von zwei eckigen Klammern, innerhalb welcher die Indizes der Zeilen und Spalten angegeben werden. Entsprechend kann auch die Bezeichnung der Spalten und Zeilen über die Funktionen colnames() und rowname() angezeigt, bzw. verändert werden (vgl. Matrizen). Darüber hinaus bietet der Dataframe noch eine spezielle Form der Adressierung von Spalten. Betrachtet man die Spalten als Variablen, deren Namen durch den Spaltennamen gegeben ist, kann mittels folgender Syntax auf die entsprechende Spalte zugegriffen werden: DataframeName$SpaltenName. Die Adressierung von Elementen innerhalb einer Variablen (Spalte) wird weiterhin mit der Indexmethode durchgeführt. Manche Programmierer bevorzugen einen schlanken Code, d.h. es soll so wenig wie möglich Text in den Programmzeilen stehen. Bei der Verwendung von Dataframes gibt es die Funktionen attach(DataframeName) und detach(DataframeName). Erstere bewirkt, dass bei der Referenz auf Variablen eines Dataframes der Name desselben nicht mehr angegeben werden muss (man spart sich also den DataframeName$). Allerdings stehen dann die Inhalten nur mehr zum Lesen zur Verfügung. Mit detach(DataFrameName) wird die direkte Referenzierung über Variablennamen wieder aufgehoben. Es sei jedoch darauf hingewiesen, dass sich einige Probleme in Zusammenhang mit der Benennung anderer Variablen ergeben können! Folgender Code zeigt die soeben beschriebenen Eigenschaften. Kopiere den Code in den Editor und führe diesen dann zeilenweise aus: A &lt;- 1:10 B &lt;- c(rep(0,5), rep(1,5)) B &lt;- factor(B, levels = c(0,1), labels = c(&quot;Male&quot;, &quot;Female&quot;)) C &lt;- c(&quot;Georg&quot;, &quot;Hanna&quot;, &quot;Belinda&quot;, &quot;Christoph&quot;, &quot;Claudia&quot;, &quot;Peter&quot;, &quot;Nikolas&quot;, &quot;Eva&quot;, &quot;Gerda&quot;, &quot;August&quot;) D &lt;- sample(15:93, 10, replace = TRUE) E &lt;- rbind(A, B, C, D) # Wandelt alle Daten in Character! Daher verwendet man die Funktion data.frame() DF &lt;- data.frame(A, B, C, D) str(DF) # Zeigt die Struktur und jeweiligen Datentypen in der Struktur Dataframe E DF DF[1,2] colnames(DF) rownames(DF) colnames(DF) &lt;- c(&quot;LNr&quot;, &quot;Geschlecht&quot;, &quot;Name&quot;,&quot;Alter&quot;) AnzZeilenDF &lt;- dim(DF)[1] # oder nrow(DF) rownames(DF) &lt;- paste0(&quot;VP&quot;, 1:AnzZeilenDF) rownames(DF) &lt;- paste0(&quot;VP&quot;, 1:nrow(DF)) # gleichwertige M?glichkeit rownames(DF) &lt;- paste0(&quot;VP&quot;, 1:dim(DF)[1]) # gleichwertige M?glichkeit DF DF$Name DF$Alter[2:3] attach(DF) Alter detach(DF) Aufgabenblock Dataframes Verwende wiederum nachfolgende Daten zum Bearbeiten der Aufgaben: id &lt;- c(11, 16, 17, 18, 19, 20, 23) # c() entspr. combine; &lt;- Zuweisung zu einer Variablen Geschlecht &lt;- c(&quot;mÃ¤nnlich&quot;, &quot;weiblich&quot;) sex &lt;- c(1, 1, 7, 1, 1, 2, 2) lalt &lt;- c(2, 3, 2, 3, 1, 1, 2) gross &lt;- c(173, 166, 178, 154, 164, 389, 181) mon &lt;- c(266, 241, 231, 265, 225, 229, 222) date &lt;- c(4, 5, 3, 3, 2, 4, 3) entsch &lt;- c(3, 4, 4, 5, 3, 1, 2) proj &lt;- c(2, 1, 2, 2, 2, 1, 2) i1 &lt;- c(3, 2, 1, 3, 4, 2, 2) i2 &lt;- c(3, 2, 1, 3, 4, 2, 2) i3 &lt;- c(3, 3, 3, 2, 2, 2, 4) i4 &lt;- c(2, 1, 2, 4, 2, 1, 4) i5 &lt;- c(2, 1, 4, 1, 3, 4, 1) erstelle eine Datenstruktur (data.frame) mit dem Namen fragebogen mit folgenden Inhalt: id, Geschlecht, sex, lalt, gross, mon, date, entsch, proj, i1, i2, i3, i4, i5 gib die 3te Zeile des fragebogens aus. verwende die Funktion head() und diskutiere das Ergebnis versuche den Befehl fragebogen$i1[1:3]. Diskutieren sie das Ergebnis, sehen Sie nach was das $ bedeutet! gib die Werte der 1’ten bis zur 3’ten Zeile der Spalte proj aus. versuche den Befehl attach() und den Befehl detach(). Verwende bei Bedarfsfall die Hilfefunktion. Data-Tables Eine erweiterte Version von Dataframes wir durch das Paket data.table11. Einer der wesentlichen Vorteile bei der Verwendung von data.table liegt vor allem in der beträchtlich schnelleren Verarbeitung - vor allem bei sehr großen Datensätzen. Das Paket beinhaltet eine Funktion (fread()) zum Lesen von csv-Dateien, welche in Hinblick auf Ladezeiten sehr großer Dateien die oft verwendete Funktion read.csv() in den Schatten stellt. Auch die Handhabung der Daten in einer data.table ist bei weitem schneller als in einem Dataframe. Trotz dieser Vorteile verzichten wir im Folgenden auf die Verwendung dieser Funktionen, da wir einerseits nicht mit big data arbeiten werden und andererseits ein Großteil der von R zur Verfügung gestellten Beispieldatensätze in Form von Dataframes und Listen vorfinden werden. Listen Um den Einschränkungen bezüglich der Dataframes zu entgehen, kann der Datentyp list verwendet werden. List-Objekte können neben verschiedenen Datentypen auch unterschiedlich große Objekte (Skalare, Vektoren, Matrizen, Dataframes), aber Objektstrukturen wie z.B. Funktionen beinhalten. Listen bilden damit eine Möglichkeit, so ziemlich alles was in R an Objekten erzeugt werden kann in einer Variablen des Typs list abzuspeichern. Eine Liste zu erzeugen erfolgt einfach über die Funktion list(). Betrachten wir zunächst folgenden Code: LI &lt;- list(&quot;Rot&quot;, c(21,32,11), TRUE, 51.23, m1) # Generiere Liste mit verschiedenen Eintr?gen str(LI) # Zeige die Struktur der Liste an names(LI) &lt;- c(&quot;Farbe&quot;, &quot;Alter&quot;, &quot;Raucher&quot;,&quot;Gewicht&quot;, &quot;Matrix&quot;) str(LI) # Alternativ kann man die Namen der Listen auch bereits bei der Erstellung durchf?hren LI1 &lt;- list(Farbe = &quot;Rot&quot;, Vec = c(21,32,11), Logi = TRUE, Wert = 51.23, Mat = m1) # Generiere Liste mit verschiedenen Eintr?gen str(LI1) LI$Farbe LI$Matrix[2, 2:3] LI[5] LI[[5]][2, 2:3] LI[6] &lt;- list(Matrix2 = m2) # F?ge Element als letztes Element der Liste hinzu str(LI) LI[6] &lt;- NULL # Entferne letztes Element der Liste LI &lt;- list(LI, list(&quot;green&quot;,12.3)) # Listen ineinander verschachteln str(LI) # Zeige die Struktur der Liste an LI[[1]]$Farbe LI[[2]][1] XLi &lt;- unlist(LI) XLi Tables Eine weitere Möglichkeit in R Daten in Objekten zu speichern bietet die Klasse der Tables. Die unterschiedlichen Formen der Tables sind am besten durch folgende Beispiele zu erklären: rm(list = ls()) F1 &lt;- factor(c(&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;C&quot;,&quot;A&quot;,&quot;C&quot;)) results &lt;- table(F1) results attributes(F1) V1 &lt;- c(&quot;Sometimes&quot;,&quot;Sometimes&quot;,&quot;Never&quot;,&quot;Always&quot;,&quot;Always&quot;,&quot;Sometimes&quot;,&quot;Sometimes&quot;,&quot;Never&quot;) V2 &lt;- c(&quot;Maybe&quot;,&quot;Maybe&quot;,&quot;Yes&quot;,&quot;Maybe&quot;,&quot;Maybe&quot;,&quot;No&quot;,&quot;Yes&quot;,&quot;No&quot;) results &lt;- table(V1,V2) results sexsmoke &lt;- matrix(c(70,120,65,140),ncol = 2,byrow = TRUE) rownames(sexsmoke) &lt;- c(&quot;male&quot;,&quot;female&quot;) colnames(sexsmoke) &lt;- c(&quot;smoke&quot;,&quot;nosmoke&quot;) sexsmoke &lt;- as.table(sexsmoke) sexsmoke sexsmoke_DF &lt;- as.data.frame(sexsmoke) library(data.table) DT &lt;- data.table( ID = 1:50, Capacity = sample(100:1000, size = 50, replace = F), Code = sample(LETTERS[1:4], 50, replace = T), State = rep(c(&quot;Alabama&quot;,&quot;Indiana&quot;,&quot;Texas&quot;,&quot;Nevada&quot;), 50)) #simple data.table command DT[Code == &quot;C&quot;, mean(Capacity), State] DT[Code == &quot;D&quot;] DT[, mean(Capacity), by = State] DT[Code == &quot;A&quot;, mean(Capacity)] Tabellen können mit der Funktion as.data.frame(tbl) leicht in die bereits bekannte Klasse des Datenframes umgewandelt werden. Attribute Allen bisher besprochenen Objekte in R können beliebige zusätzlichen Eigenschaften (Attribute) zugewiesen werden. Attribute kann man sich als Namenslisten vorstellen, welche durch die Funktion attr() festgelegt werden können. str(sexsmoke) attr(sexsmoke, &quot;dim&quot;) y &lt;- 1:10 attr(y, &quot;Mein_Attribut&quot;) &lt;- &quot;y ist ein Vektor&quot; attr(y, &quot;Mein_Attribut&quot;) str(attributes(y)) Auf den Umgang und die Verwendung von Attributen wird in folgenden Kapiteln entsprechend verwiesen. Vor allem beim Import von Daten (z.B. SPSS Ergebnisse einer Limesurveyumfrage) können die Attribute für die Speicherung zu Metainformation einer Variablen (Itemformulierung zu einer Variablen) sehr hilfreich sein. Lösungen Lösungen zu Aufgabenblock Copy und Paste # Aufgabe 1 v &lt;- c(1,4,4,3,2,2,3) # Aufgabe 2 v[c(2,3,4)] # Aufgabe 3 dat &lt;- data.frame( time = factor(c(&quot;Lunch&quot;,&quot;Dinner&quot;), levels = c(&quot;Lunch&quot;,&quot;Dinner&quot;)), total_bill = c(14.89, 17.23) ) dat #&gt; time total_bill #&gt; 1 Lunch 14.89 #&gt; 2 Dinner 17.23 # Aufgabe 4 &amp; 5 library(ggplot2)# Load the ggplot2 package # Very basic bar graph ggplot(data=dat, aes(x = time, y = total_bill)) + geom_bar(stat=&quot;identity&quot;) # Map the time of day to different fill colors ggplot(data=dat, aes(x = time, y = total_bill, fill = time)) + geom_bar(stat = &quot;identity&quot;) ## This would have the same result as above # ggplot(data=dat, aes(x=time, y=total_bill)) + # geom_bar(aes(fill=time), stat=&quot;identity&quot;) # Add a black outline ggplot(data = dat, aes(x = time, y = total_bill, fill = time)) + geom_bar(colour = &quot;black&quot;, stat = &quot;identity&quot;) # No legend, since the information is redundant ggplot(data=dat, aes(x=time, y = total_bill, fill = time)) + geom_bar(colour = &quot;black&quot;, stat = &quot;identity&quot;) + guides(fill = FALSE) # Aufgabe 6 data() ?tips ?french_fries # Aufgabe 7 Dat_FF &lt;- french_fries str(Dat_FF) # Aufgabe 8 library(haven) bigfive &lt;- read_sav(&quot;Data/bigfive.sav&quot;) View(bigfive) # Aufgabe 9 library(readxl) bigfive &lt;- read_excel(&quot;Data/bigfive.xls&quot;) View(bigfive) Lösungen zu Aufgabenblock Vektoren mean(gross) # A1: Aufruf der Funktion mean(). gross1 &lt;- gross # A2: Kopiere Werte von gross in gross1 gross1[1] &lt;- NA # A3: setzte den ersten Wert von gross1 auf NA (not available) = missing value mean(gross1) # A4: BEACHTE, dass mean nun NA ist -&gt; Markiere mean und dr?cke F1 mean(gross1, na.rm = TRUE) # A5: nun wird der Mittelwert richtig berechnet! mean(gross1, trim = 0.5, na.rm = TRUE) # A6 gross_prod &lt;- gross[2]*gross[3] # A7 sex[3] &lt;- 1 # A8 x &lt;- 50:1 # A9 x[-2] # A10: Alle Werte bis auf den zweiten Wert der Liste. x &lt;- seq(from = 1, # A11: vgl. gegebenenfalls in der Hilfe unter seq() to = 10, by = 2) x &lt;- seq(from = 10, # A12 to = 2, by = -2) x &lt;- c(seq(from = 0, # A13 to = 10, by = 2), 50) class(x) # A14 x_c &lt;- as.character(x) # A15 class(x_c) # A16 x_n &lt;- as.numeric(x) # A17 class(x_n) # A18 sum(gross &gt;= 173) # A19 which(gross %in% 181) # A20 Lösungen zu Aufgabenblock Faktoren # Aufgabe 1 x &lt;- c(1, 2, 3, 1, 1, 2, 2) x_fact &lt;- factor(x, levels = c(1, 2, 3), labels = c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;)) # Aufgabe 2 x_fact2 &lt;- x_fact levels(x_fact2) &lt;- c(&#39;S1&#39;, &#39;S2&#39;, &#39;S3&#39;) table(x_fact2) # Aufgabe 3 x_fact3 &lt;- factor(x_fact2, levels = c(&quot;S3&quot;, &quot;S1&quot;, &quot;S2&quot;)) table(x_fact2) table(x_fact3) Lösungen zu Aufgabenblock Matrizen X &lt;- cbind(lalt, sex, gross) # A1 Z &lt;- rbind(lalt, sex, gross) # A2 X[2,3] # A3 X[3,] # A4 X[3:5,1:2] # A5 colnames(X) # A6 ColNames &lt;- c(&quot;Alter&quot;, &quot;Gewicht&quot;, &quot;Gr??e&quot;) # A7 colnames(X) &lt;- ColNames # A8 namen &lt;- c(&quot;Walter&quot;, &quot;Gerda&quot;,&quot;Hannes&quot;, &quot;Ute&quot;, &quot;Hanna&quot;,&quot;Doris&quot;,&quot;Karin&quot;) # A9 rownames(X) &lt;- namen # A10 fix(X) # A11 dim(X) # A12 length(X) # A13 cbind(X, X[,3] / 100) which(X[,3] &gt; 200) Lösungen zu Aufgabenblock Dataframes fragebogen &lt;- data.frame(id, sex, lalt, gross, mon, date, entsch, proj, i1, i2, i3, i4, i5) # A1 fragebogen[3,] # A2 head(fragebogen) # A3 fragebogen$i1[1:3] # A4 fragebogen[1:3,9] # A5 fragebogen[1:3,&quot;i1&quot;] # A5 - Alternative L?ung mit Verwendung des Spaltennamens attach(fragebogen) # A6 detach(fragebogen) # A6 das Wissen um die Dimension einer Matrix wird vor allem noch bei Programmschleifen hilfreich sein. Mehr davon später.↩ Paket von Matt Dowle, kann über CRAN-Server geladen werden.↩ "],
["rarbeiten.html", "7 Rarbeiten Lesen und speichern von Dateien", " 7 Rarbeiten Unabhängig vom verwendeten Statistik-Programm werden wir in den meisten Fällen Daten nicht erst im jeweiligen Programm definieren und erfassen, sondern auf bereits vorliegende Daten zurückgreifen. Eine wichtige Ausnahme ist dabei die Simulation von Daten. Bereits mit einem normalen Desktop-PC ist es möglich, eine Unmenge an Daten (surrogate data) im Handumdrehen zu erzeugen und diese mittels statistischer Verfahren, Modelle und Algorithmen innerhalb kürzester Zeit auszuwerten. Zur Prüfung der Eigenschaften von Modellen und Algorithmen ist diese Vorgehensweise ein wichtiges Hilfsmittel. Zur Erfassung von Echtdaten wird aber üblicherweise kein statistisches Analyseprogramm verwendet. Daher liegen diese Daten auch in verschiedensten Formaten vor und es ist einer der ersten Schritte in der statistischen Datenanalyse, diese Daten vom jeweiligen Format in ein für das Statistikprogramm lesbares umzuwandeln. Die am häufigsten verwendeten Formate mit denen wir es derzeit zu tun haben sind: R-Dateien im RData, rda und rds Format Textdateien im csv, dat, txt Format SPSS, JAMOVI, etc. Dateien (sav, omv, etc.) Excel-Tabellen im xls, oder xlsx Format Binäre Daten im bin Format Proprietäre Formate diverser Labor- und Messgeräte Im Folgenden beschränken wir uns auf die üblichsten Fileformate, den R-, Text-, SPSS- und Excel-Dateien. Lesen und speichern von Dateien Das Lesen und Speichern von Dateien kann entweder direkt im RStudio über das Environment-Pane, oder über einen entsprechenden R-Code in der Konsole, bzw. über den Source-Pane durchgeführt werden. Zu unterscheiden sind die verschiedenen Dateitypen, von denen es abhängt, welche Funktion zu wählen ist. R-Dateien Liegen Daten bereits im R-eigenen Format vor, können diese einfach mit der Funktion load(Dateiname) eingelesen werden. Bezüglich der Dateierweiterung unterscheidet R folgende Typen: .RData: der Inhalt des zum Zeitpunkt des speicherns (save()) vorhandenen Environments. .rda: Kurzbezeichnung für RData. .rds: speichert ein einzelnes R-Objekt. Der Vorteil dieser Datenformate liegt darin, dass die Datenstrukturen, wie z.B. Datentypen der Spalten (numerisch, character, factor) erhalten bleiben. Bei anderen Dateiformaten ist dies nicht automatisch gegeben. In einem ersten Schritt verwenden wir die im Environment-Pane vorhandenen Möglichkeiten Files zu laden und zu speichern. Kopiere zuerst den nachfolgenden Code in ein neues R-Script, speicher dieses unter dem Namen 07_RArbeiten_Files.R und führe anschließen den Code zeilenweise aus. # Initialisierung rm(list = ls()) if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) pacman::p_load(here) # Ende Initialisierung Verwende nun das Symbol Open File im Environment-Pane und wähle die Datei bigfive.RData im entsprechenden Datenverzeichnis (gegebenenfalls noch von Daten zum Seminar herunterladen und lokal am Rechner speichern). Führe folgende Arbeitsschritte durch: Im Konsolenfenster wird die Funktion zum Laden der Datei (load(xxx)) angezeigt. Kopier diese Zeile in den Editor. Erzeuge eine Kopie dieses Objektes und benenne diese mit KopieBigFive Verwende das Symbol Speichern im Environment-Pane und speichere den Inhalt des Environments unter den Namen BigFive_New_1. Im Konsolenfenster wird die Funktion zum Speichern der Datei (save.image(xxx)) angezeigt. Kopier diese Zeile in den Editor. Ruf die Hilfefunktion auf um herauszufinden, was es mit dieser Funktion auf sich hat. Bereinige das Environment unter Verwendung des Pinsel-Symbol. Lade die soeben gespeicherte Datei (BigFive_New_1.RData) mit dem Symbol Open File. Beachte, dass nun beide Objekte wieder im Environment zur Verfügung stehen. Nachfolgender Code zeigt die soeben besprochenen Aufgabenschritte. load(here(&quot;Data/bigfive.RData&quot;)) # A1 KopieBigFive &lt;- bigfive # A2 save.image(here(&quot;Data/BigFive_1.RData&quot;)) # A3 rm(list = ls()) # A4 load(here(&quot;Data/BigFive_1.RData&quot;)) # A5 save.image(here(&quot;Data/BigFive_2.RData&quot;)) # A6 rm(list = ls()) # A7 load(here(&quot;Data/BigFive_2.RData&quot;)) # A8 saveRDS(KopieBigFive, file = here(&quot;Data/BigFive_3.rds&quot;)) rm(list = ls()) KopieBigFive &lt;- readRDS( here(&quot;Data/BigFive_3.rds&quot;) ) Im folgenden werden ergänzende Möglichkeiten zum Speichern/Laden von Daten gezeigt. Mit der Funktion saveRDS() können einzelne Objekte gespeichert und mit readRDS() auch wieder geladen werden. Will man mehrere, aber nicht alle Objekte des Environments speichern, kann dies durch Angabe der Objektnamen und der Funktion save() durchgeführt werden. Seminar &lt;- &quot;R-Intro&quot; V1 &lt;- 1:10 M1 &lt;- matrix(1, 3, 3) M2 &lt;- matrix(5, 8, 3) save(Seminar, V1, file = here(&quot;Data/BigFive_4.RData&quot;) ) rm(list = ls()) load(here(&quot;Data/BigFive_4.RData&quot;)) rm(list = ls()) Text-Dateien Mit der read.csv(), read.table() und verwandten Funktionen können Daten aus Textdateien (txt) importiert werden. read.table() ist die Basisfunktion zum Import von Textdateien. read.csv() und read.csv2() sowie einige andere Funktionen sind Anpassungen an häufig auftretenden Fülle. CSV12 ist für viele Tabellenkalkulationen und andere Anwendungen ein übliches Exportformat. Irreführend bei diesem Format ist oftmals die Verwendung der Trennzeichen für unterschiedliche Daten. Der Name csv suggeriert, dass ein Kommazeichen die Datensätze innerhalb der Datei trennt. Tatsächlich kann man aber ein beliebiges Zeichen verwenden. Am häufigsten findet man den Tabulator, oder den Strichpunkt als Trennzeichen. Bezüglich des Kommazeichens sollte man noch vor dem Import einer Datei prüfen, ob dieses als Trennzeichen für Dezimalzahlen verwendet wurde, oder ob (wie im englischen Sprachraum üblich) der Punkt die Dezimaltrennung kennzeichnet. Bemerkung bezüglich der Leistungsfähigkeit von Funktionen beim Lesen von (wirklich) großen Dateien: die read.csv() und damit verwandten Funktionen weisen bei big data im Vergleich zu optimierten Funktionen wie z.B. fread() (aus dem Paket data.table) wesentlich höhere Ladezeiten auf. Bei kleinen Datensätzen ist dies jedoch zu vernachlässigen. Um eine Textdatei zu laden, betrachten wir zunächst wie RStudio dabei vorgeht. Im Environment-Pane finden wir bei den Reitern die Möglichkeit Import-Dataset. Folgende Optionen werden angeboten: From Text (base) … From Text (readr) … From SPSS … From Excel … From SAS … From Stata … Lade die Datei ATM.txt mit der Option From Text (base) … und kopiere die Befehlszeilen in den Editor. Diskutiere die Ergebnisse. Entferne anschließend alle Inhalte aus dem Environment und wiederhole das Laden der Datei mit der Option From Text (readr) …. Vergleiche die Funktionen und diskutiere den Unterschied der beiden Funktionen. ATM &lt;- read.delim(&quot;C:/NextCloud/LEHRE2019/18WS R-Intro/Data/ATM.txt&quot;) View(ATM) rm(list = ls()) library(readr) ATM &lt;- read_table2(&quot;Data/ATM.txt&quot;) View(ATM) SPSS-Dateien Wie bei den Textdateien, verwenden wir in einem ersten Schritt die Importfunktion von RStudio. Lade die Datei bigfive.sav (eine SPSS Datei) und kopiere den Code aus der Konsole in den Editor. rm(list = ls()) library(haven) bigfive &lt;- read_sav(&quot;Data/bigfive.sav&quot;) View(bigfive) str(bigfive) Überprüfe die Struktur des geladenen Objektes. Auffallend ist der bislang noch nicht besprochenen Datentyp tbl_df. Dabei handelt es sich im Wesentlichen um einen Dataframe. Gehe in den Files-Pane zu den Packages und suche nach dem Paket haven. Öffne die Doku des Pakets, bzw. öffne die Hilfe zu haven::read_sav() direkt. Weiterführend Information zu diesem Datenformat ist unter anderem auf folgender Seite zu finden: Tibble Eine weitere - zum Einlesen von SPSS-Dateien - geeignete Funktion wird im Paket foreign angeboten (read.spss()). Aufgabe: Stelle fest, ob in deinem Repository dieses Paket bereits geladen ist (Hinweis: vgl. List of Packages). Falls nicht, lade das Paket samt abhängigen Paketen. Bereinigen das Environment und lade die Datei bigfive.sav mit Hilfe der Funktion read.spss(). Überprüfe und diskutiere den Inhalt, bzw. die Datentypen des geladenen Objektes. ip &lt;- as.data.frame(installed.packages()[,c(1,3:4)]) rownames(ip) &lt;- NULL ip &lt;- ip[is.na(ip$Priority),1:2, drop = FALSE] print(ip, row.names = FALSE) library(foreign) BF &lt;- read.spss(&quot;Data/bigfive.sav&quot;, to.data.frame = TRUE) str(BF) Neben den Paketen haven und foreign gibt es noch weitere Packages welche Funktionen zum Einlesen von SPSS-Dateien beinhalten (z.B. Hmisc mit der Funktion spss.get()). Die derzeit wahrscheinlich beste Funktion ist im Paket haven zu finden, aber auch alle anderen Funktionen aus anderen Packages erfüllen i.A. ihren Zweck. Excel-Dateien Das Laden und Speichern von Excel-Dateien sollte aufgrund der Häufigkeit mit der Daten aus diesem Programm in R übernommen werden keine Hexerei sein. Erfahrungsgemäß ist aber gerade dieses Format (xls und xlsx) nicht so einfach zu handhaben wie zu erwarten wäre. Die einfachste (und oft durchgeführte Alternative) ist die Speicherung von xls-Tabellen als csv-Dateien. Anderenfalls gibt es natürlich verschiedene Packages mit Funktionen die derartige Dateien direkt lesen und schreiben können. Folgende Packages enthalten Funktionen zum Lesen von Excel-Files: readxl (kann nur Excel-Dateien lesen, nicht schreiben) xlsx XLConnect gdata u.v.m. Die Entscheidung, welches davon genutzt wird, bleibt dem Anwender überlassen. RStudio verwendet im Import das readxl. Zum Kennenlernen werden wir in einem ersten Schritt die Datei bigfive_excel.xls über den Datenimport von RStudio laden. Bitte den entsprechenden Code in den Editor kopieren. Anschließend testen wir die Funktion des Packages xlsx. Für die Verwendung von XLConnect und gdata sei aus zeitlichen Gründen auf die entsprechende Dokumentation verwiesen. Neben dem Einlesen von Excel-Files ist das Speichern von Ergebnissen in Excelformat für die weitere Verwendung des Endnutzers sehr wichtig. Wie Daten in ein Excelfile übertragen und dieses auch abgespeichert wird, ist dem nachfolgenden Code zu entnehmen. Kopiere den Code in den Editor und führe diesen zeilenweise aus. Diskutiere die Ergebnisse. rm(list = ls()) library(readxl) ptm &lt;- proc.time() bigfive_excel_1 &lt;- readxl::read_excel(&quot;Data/bigfive_excel.xls&quot;) # Funktion prüft ob xls oder xlsx proc.time() - ptm str(bigfive_excel_1) bigfive_excel_2 &lt;- readxl::read_xls(&quot;Data/bigfive_excel.xls&quot;) # Funktion lädt nur xls Format bigfive_excel_3 &lt;- readxl::read_xlsx(&quot;Data/bigfive_excel.xlsx&quot;) # Funktion lädt nur xlsx Format library(xlsx) ptm &lt;- proc.time() bigfive_excel_4 &lt;- xlsx::read.xlsx(&quot;Data/bigfive_excel.xlsx&quot;, sheetIndex = 1) proc.time() - ptm write.xlsx(bigfive_excel_4, &quot;Data/bigfive_excel_Write.xlsx&quot;, sheetName = &quot;Datenblatt&quot;, col.names = TRUE, row.names = TRUE, append = FALSE, showNA = TRUE, password = NULL) Bemerkung zu Excel-Packages: neben den oben angeführten Packages existieren noch einige weitere, die Funktionen mit Excel-Read-Write anbieten. Manche verlangen Java, andere Perl-Scripts. Einige sind spezialisiert auf effizienten Zugriff und der Bearbeitung von Zellen, andere sind extrem schnell beim Laden von großen Dateien. Üblicherweise reichen die beiden vorgestellten Pakete. Dateien vom Web Die verschiedensten Dateiformate können auch von einer Website oder eine FTP-Server geladen werden. Nachfolgend ein Beispiel, wie eine Datei direkt von einem Server eingelesen werden kann. WebData &lt;- read.table(&quot;http://www.tuval.at/wp-content/uploads/Airquality.txt&quot;, header = FALSE) Comma Separated Values↩ "],
["rechnen-mit-r.html", "8 Rechnen mit R Deskriptive Datenanalyse Graphiken der deskriptiven Statistik Lösungen", " 8 Rechnen mit R Deskriptive Datenanalyse Ziel einer deskriptiven Analyse ist eine möglichst genaue Beschreibung von Daten mit einer möglichst kleinen Menge an Zahlen. Dazu eignen sich vor allem: Kennwerte Tabellen Graphiken Mit der deskriptiven Analyse ist es darüber hinaus möglich, Daten auf ihre Plausibilität und Richtigkeit zu prüfen. Die Bedeutung einer genauen deskriptiven Analyse und die korrekte Interpretation der Ergebnisse dieser Analyse kann nicht hoch genug eingeschätzt werden. Liegen erst einmal Daten vor ist es entweder zu schwierig, aufwendig, oder zu spät am Versuchsdesign noch etwas nachträglich zu ändern. Allerdings kann man mit einer sorgsamen deskriptiven Analyse durchaus grobe Fehler bei der weiteren Analyse mit statistischen Verfahren vermeiden. Eine der wichtigsten Erkenntnisse für jeden Datenanalytiker ist, dass schlechte Daten nur schlechte Ergebnisse liefern können (garbage in - garbage out Problem). Daher sind vor Beginn jeder statistischen Analyse von Daten die deskriptiven Analysen unerlässlich. Folgende Kapitel versuchen einen groben Überblick über die Möglichkeiten der deskriptiven Analyse mit R zu geben. Da es diesbezüglich bereits eine sehr große Anzahl an guten Paketen mit sehr vielen hilfreichen Funktionen gibt, ist es im Rahmen dieser LV unmöglich auf alle Details einzugehen. Unser Streifzug durch die deskriptive Statistik mit R ist somit als Anstoß und Motivation für weitere, selbstständig durchzuführende Studien zu diesem Thema zu sehen. Kennwerte der deskriptiven Statistik Kennwerte der deskriptiven Statistik lassen sich bezüglich der Beschreibung der Häufigkeiten, zentralen Tendenzen, Verteilungseigenschaften und der Dispersion unterteilen. Häufigkeiten Zentrale Tendenzen: Mittelwert, Median, Modus Verteilungseigenschaften: Schiefe (skew), Breite (kurtosis), Minimum, Maximum Dispersion: Spannweite, Quantile, Varianz, Standardabweichung, Standardfehler. Für die meisten der genannten Kennwerte gibt es im R-Basispaket entsprechende Funktionen. Manche der Funktionen (z.B. Schiefe und Kurtosis) sind in Paketen (z.B. moments) verfügbar. Der Standardfehler kann ebenfalls in einem Paket (z.B. plotrix mit Funktion std.error()) berechnet werden. Da die Berechnung jedoch sehr einfach ist, kann man sich hier selbst schnell mit einer Funktion behelfen. Aufgabe: programmiere die Berechnung des Standardfehlers als Funktion. Der Standardfehler berechnet sich: \\(SE = \\frac{s_x}{\\sqrt{N}}\\) oder \\(SE = \\sqrt{\\frac{s^2_x}{N}}\\) Bemerkung: verwende die Extract Function (Ctrl Alt X) für die Erstellung der Funktion. table(DF$geschlecht) mean(DF$alter) median(DF$alter) skewness(DF$alter) agostino.test(DF$alter, alternative = c(&quot;two.sided&quot;)) kurtosis(DF$alter) anscombe.test(DF$alter, alternative = c(&quot;two.sided&quot;)) min(DF$alter) max(DF$alter) range(DF$alter) quantile(DF$alter) var(DF$alter) sd(DF$alter) # Hier den Code f?r den Standardfehler einbauen Eine nützliche Funktion ist summary(mydata). Darüber hinaus stehen zahlreiche Pakete für die Erstellung deskriptiver Statistiken zur Verfügung. Nachfolgend eine Auswahl von Paketen: Hmisc pastecs psych doBy summary(DF) summary(DF$alter) pacman::p_load(doBy, Hmisc, pastecs, psych) Hmisc::describe(DF$alter) pastecs::stat.desc(DF$alter) psych::describe(DF$alter) psych::describeBy(DF$alter, group = DF$geschlecht) doBy::summaryBy(alter + BMI ~ med + geschlecht, data = DF, FUN = function(x) { c(m = mean(x), s = sd(x)) } ) Jedes dieser Pakete beinhaltet eine Vielzahl nützlicher Funktionen, die im Rahmen dieses Kurses nicht besprochen werden können. Um zumindest den Einblick in die Vielfalt der Funktionen eines Paketes zu erhalten, öffne die Hilfe für das Paket Hmisc und blättere durch den alphabetisch sortierten Funktionsumfang des Paketes - sehr beeindrucken, oder? Graphiken der deskriptiven Statistik Graphiken sind die beste Form der Darstellung von Ergebnissen! Es wird nicht immer möglich sein, entsprechende Graphiken zu erstellen, aber wenn möglich, sollten Ergebnisse immer durch Graphen dargestellt werden! In RStudio werden die Ergebnisse einer Grafikfunktion im Files-Pane unter Plots ausgegeben. Graphen des Basispakets Das Basispaket von R bietet einige nützliche Grafikfunktionen, die sich für eine einfache Darstellung von Daten bestens eignen. Diese sind: plot() - Standardfunktion zum Erstellen von Diagrammen hist() - Erstellen von Histogrammen pie() - Erstellen von Kreisdiagrammen barplot() - Erstellen von Säulendiagrammen boxplot() - Erstellen von Boxplots (beinhaltet: Maximalwert, Minimalwert, Median, Quartile, Ausreißer) dotchart() - Erstellen von Punktdiagrammen # plot() function plot(DF$BMI, type = &quot;s&quot;, main = &quot;BMI&quot;) points(DF$BMI, cex = .5, col = &quot;dark red&quot;) # hist() function hist(DF$BMI, breaks = 20, main = &quot;Altersverteilung&quot;, xlab = &quot;Alter in Jahren&quot;, ylab = &quot;H?ufigkeiten&quot;) # pie() function AK_Graph &lt;- table(DF$ak) pie(AK_Graph, radius = 0.6) # barplot() function BMI_Graph &lt;- summaryBy(BMI ~ ak, DF) barplot(BMI_Graph$BMI.mean) # boxplot() function boxplot(DF$BMI ~ DF$ak) # dotchart() function dotchart(BMI_Graph$BMI.mean, labels = BMI_Graph$ak) Speziellere Graphiken können mit folgenden Funktionen dargestellt werden: contour() - Erstellen von Konturdiagrammen, plotten von Isolinien forestplot - (aus dem Zusatzpaket “rmeta”) erzeugt ein so genanntes “Forest Plot” zusammen mit einer Texttabelle. map - (aus dem Paket “maps” und “mapdata”) erstellt Karten von Ländern, Kontinenten und der Welt metaplot - (aus dem Zusatzpaket “rmeta”) erzeugt ein so genanntes “Forest Plot” (Meta-Analyse-Plot), welches im Rahmen von Metaanalysen gängig ist. persp() - Erstellen von Dreidimensionalen Abbildungen Zur Bearbeitung von Details innerhalb von Graphiken stehen z.B. folgende Funktionen zur Verfügung: par() - Setzen von grafischen Parametern title() - Beschriftung von Diagrammen Alle Graphiken die in R erzeugt werden, können in den verschiedensten Dateiformaten abgespeichert werden: jpeg() - speichert die Grafik als jpeg-Datei ab. png() - speichert die Grafik als png-Datei ab. pdf() - speichert eine Grafik als PDF-Datei ab. postscript() - Speichert die Grafikausgabe in eine Postscript-Datei. savePlot() - Speichert die aktuelle Grafik in eine Datei devSVG() - speichert eine Grafik als SVG-Datei ab. Dazu ist das Zusatzpaket RSvgDevice erforderlich. Graphen mit ggplot2 Mit dem Paket ggplot2 erweitern sich die Möglichkeiten bei der Erstellung und Gestaltung von Graphiken erheblich. Es gehört zu den mächtigsten und umfangreichsten Pakten zur Erstellung von Grafiken. Gerade wegen dieser Eigenschaft kann es vor allem für Einsteiger oft schwierig werden. Das Paket bietet aber die Einsteigerfunktion qplot() (für Quick Plot). Für Standardgraphiken ist diese Funktion sehr hilfreich, denn viele der komplexen Möglichkeiten in ggplot2 bleiben bei dieser Funktion verborgen. Basierend auf den Grundlagen des Buches The grammar of graphics von Leland Wilkinson baute Wickham sein Datenvisualisierungspaket auf und übernahm die grundlegenden Thesen des Buches, die auch heute noch als richtungsweisend für die Statistik gelten. Laut Leland lässt sich jeder Datensatz, egal welcher Komplexität, leicht darstellen, wenn man ihn sinnvoll in Ästhetik und Geometrie unterteilt. Mittels dieser Differenzierung können Aufgabenbereiche getrennt und Zuständigkeiten an verschiedene Aspekte des Plots übergeben werden. Sobald komplexere Daten visualisiert werden sollen, zeigen sich die Vorteile von ggplot2: feste Schema: jeder Plot kann/muss nach einem Muster abgearbeitet werden. Das fährt unter anderem dazu, dass der Code meist sehr einfach gehalten ist und bei nachträglichen Änderungen nur wenigen Abwandlungen unterzogen werden muss. Farb- oder Formeinsatz: innerhalb des Plots wird automatisch eine Legende berechnet, die ebenfalls jederzeit manuell gestaltbar ist. Dies steht ganz im Gegensatz zu R nativen Plots, die durchweg individuell durchprogrammiert werden müssen. zeitsparend Quick Plot mit ggplot2 Die qplot()-Funktion folgt nicht dem typischen ggplot2-Schema und ist eher als Einstieg ins Plotting gedacht, ermöglicht jedoch dieselbe Plotvisualisierung wie die ggplot()-Funktion. Ihr Aufbau und ihre Gestaltung wird lediglich durch verschiedenste Parameter bestimmt. Öffne folgenden Link Quick Plot Einstieg und kopiere den Code der nach dem Text Here are some examples using automotive data … folgt in den Editor. Weiter nützliche Hinweise zu Quick Plot findest du unter Um Quick Plot Cheat Sheet. pacman::p_load(ggplot2) # create factors with value labels mtcars$gear &lt;- factor(mtcars$gear,levels=c(3,4,5), labels=c(&quot;3gears&quot;,&quot;4gears&quot;,&quot;5gears&quot;)) mtcars$am &lt;- factor(mtcars$am,levels=c(0,1), labels=c(&quot;Automatic&quot;,&quot;Manual&quot;)) mtcars$cyl &lt;- factor(mtcars$cyl,levels=c(4,6,8), labels=c(&quot;4cyl&quot;,&quot;6cyl&quot;,&quot;8cyl&quot;)) # Kernel density plots for mpg # grouped by number of gears (indicated by color) qplot(mpg, data=mtcars, geom=&quot;density&quot;, fill=gear, alpha=I(.5), main=&quot;Distribution of Gas Milage&quot;, xlab=&quot;Miles Per Gallon&quot;, ylab=&quot;Density&quot;) # Scatterplot of mpg vs. hp for each combination of gears and cylinders # in each facet, transmittion type is represented by shape and color qplot(hp, mpg, data=mtcars, shape=am, color=am, facets=gear~cyl, size=I(3), xlab=&quot;Horsepower&quot;, ylab=&quot;Miles per Gallon&quot;) # Separate regressions of mpg on weight for each number of cylinders qplot(wt, mpg, data=mtcars, geom=c(&quot;point&quot;, &quot;smooth&quot;), method=&quot;lm&quot;, formula=y~x, color=cyl, main=&quot;Regression of MPG on Weight&quot;, xlab=&quot;Weight&quot;, ylab=&quot;Miles per Gallon&quot;) # Boxplots of mpg by number of gears # observations (points) are overlayed and jittered qplot(gear, mpg, data=mtcars, geom=c(&quot;boxplot&quot;, &quot;jitter&quot;), fill=gear, main=&quot;Mileage by Gear Number&quot;, xlab=&quot;&quot;, ylab=&quot;Miles per Gallon&quot;) Aufbau von ggplot213 Bevor man Graphiken mit ggplot() erstellt, sollte man sich folgende Fragen stellen: Data: welche Daten will man visualisieren? Geoms: will man Punkte, Linien, Polygone? Mappings: welche Ästhetischen Attribute sollten für geometrischen Objekte festlegt werden? Scales: wie sollten Merkmalsausprägungen auf “physikalische Einheiten” der geometrischen Objekte (z. B. Form, Durchmesser oder Farbe) abgebildet werden (definiert die Legende)? Coord: wie sollte das Koordinatensystem (Achsen und Gitternetzlinien) dargestellt werden? Faceting: sollte die Datenmengen unterteilt werden (z. B. getrennt nach einem Gruppenfaktor in unterschiedlichen Graphen)? Stats: sollten die Daten vor der Darstellung nochmal statistisch transformieren werden? Die Antworten zu diesen Fragen bestimmen die Art und Weise wie im Rahmen des strukturellen Aufbaus von ggplot2 eine Graphik aufgebaut wird. Eine ggplot-Graphik ist prinzipiell in sogenannte layers aufgebaut: Abbildung 27: Layers in ggplot Jeder Layer kann für sich gesehen ein bestimmtes Aussehen (aesthetic) und auch bestimmte geometrische Objekte (Balken, Linien, etc.) beinhalten. Abbildung 28: Anatomie von ggplot Die Aesthetics (aes()) bestimmen das Aussehen wie z.B. Farbe, Größe, Positionen, Stile, etc. Abbildung 29: Aesthetics in ggplot Die geometrischen Objekte in einem Plot definieren die Darstellungsform der Daten. Auszugsweise mögliche geom’s von ggplot: geom_bar() geom_point() geom_line() geom_histogram() geom_boxplot() Verwendung von ggplot2 Aufgrund des enormen Leistungsumfangs von ggplot, wollen wir im folgenden (mit der Topdown-Methode) einen Einblick in die vielseitige Verwendbarkeit des Pakets durch Beispiele aus Cookbook R gewinnen. Öffne den Link und gehe im Kapitel Graphs with ggplot2 zu den Bar and line graphs (ggplot2). Gehen wir einmal davon aus, dass wir für unsere Daten aus hyper.sav ein Balkendiagramm des durchschnittlichen BMI getrennt nach Altersklasse (x-Achse) und Geschlecht (Balken) erzeugen wollen. Wir durchsuchen die geöffnete Cookbook-Seite und finden folgende Darstellung als passend für unsere Daten: Abbildung 30: Vorlage für das gewünschte Balkendiagramm Im ersten Schritt kopieren wir den entsprechenden Code in unseren Editor und führen diesen aus (Hinweis: kopiere auch den Code der Website, in dem die Daten definiert werden!). Wenn dieser Code auch denselben Output wie auf der Website erzeugt, versuchen wir nun durch Änderung der entsprechenden Daten im Code diesen Plot an unsere Daten (hyper.sav) anzupassen. Nachdem der Graph für unsere Daten adaptiert wurde, speichern wir diesen in das Verzeichnis /images. dat1 &lt;- data.frame( sex = factor(c(&quot;Female&quot;,&quot;Female&quot;,&quot;Male&quot;,&quot;Male&quot;)), time = factor(c(&quot;Lunch&quot;,&quot;Dinner&quot;,&quot;Lunch&quot;,&quot;Dinner&quot;), levels=c(&quot;Lunch&quot;,&quot;Dinner&quot;)), total_bill = c(13.53, 16.81, 16.24, 17.42)) head(dat1) ggplot(data = dat1, aes(x = time, y = total_bill, fill = sex)) + geom_bar(stat = &quot;identity&quot;, position=position_dodge(), colour = &quot;black&quot;) + scale_fill_manual(values=c(&quot;#999999&quot;, &quot;#E69F00&quot;)) Datenformat in ggplot2 ggplot2 ist grundsätzlich auf sogenannte “long format” Daten ausgelegt. Um die Repräsentativität von “wide format” Datensätzen zu erhöhen, also Datensätze mit sehr vielen verschiedenen Merkmalen, gibt es in R die Pakete reshape2 und plyr, die häufig zur Datenmanipulation14 verwendet werden. Lösungen 8.0.1 Lösung Funktion Standardfehler SE &lt;- function(x) { SE &lt;- sd(x) / length(x) return(SE) } SE(DF$alter) 8.0.2 Lösung ggplot Beispiel 1 dat1 &lt;- summaryBy(BMI ~ ak + geschlecht, DF) str(dat1) ggplot(data = dat1, aes(x = ak, y = BMI.mean, fill = geschlecht)) + geom_bar(stat=&quot;identity&quot;, position=position_dodge(), colour=&quot;black&quot;) + scale_fill_manual(values=c(&quot;#999999&quot;, &quot;#E69F00&quot;)) Abbildungen aus Andy Field, Discovering Statistics using R.↩ Datenmanipulation meint hierbei das Schichten, Gruppieren und Zusammenfassen verschiedener Daten.↩ "],
["datenauswertung-lime-survey.html", "9 Datenauswertung Lime Survey Datenvorverarbeitung Deskriptive Statistik Lösungen", " 9 Datenauswertung Lime Survey Im nachfolgenden Beispiel werden die Daten des World-Knowledge-Test ausgewertet. Bei diesem Test handelt es sich um eine einfache Umfrage, welche mit dem Online-Survey-Tool LimeSurvey erstellt wurde. Die Befragung richtete sich an ca. 300 StudentInnen der Universität Salzburg. Die Daten sollen im Folgenden zur Auswertung einfacher deskriptiver Statistiken mit R verwendet werden. Abbildung 31: Export der Daten aus Lime Survey LimeSurvey bietet die Möglichkeit, Umfragedaten in verschiedensten Formaten zu exportieren. Wie in obiger Dartellung ersichtlich, bietet sich unter anderem der Export einer R-Daten als auch R-Syntax Datei. Nach Durchführung des Exorts stehen zwei Dateien zur Verfügung: Abbildung 32: Files die aus Lime Survey exportiert wurden Nachfolgend ein Auszug aus der R-Syntaxdatei: data &lt;- read.csv(&quot;survey_791736_R_data_file.csv&quot;, quote = &quot;&#39;\\&quot;&quot;, na.strings = c(&quot;&quot;, &quot;\\&quot;\\&quot;&quot;), stringsAsFactors = FALSE) # LimeSurvey Field type: F data[, 1] &lt;- as.numeric(data[, 1]) attributes(data)$variable.labels[1] &lt;- &quot;id&quot; names(data)[1] &lt;- &quot;id&quot; # LimeSurvey Field type: DATETIME23.2 data[, 2] &lt;- as.character(data[, 2]) attributes(data)$variable.labels[2] &lt;- &quot;submitdate&quot; names(data)[2] &lt;- &quot;submitdate&quot; # LimeSurvey Field type: F data[, 3] &lt;- as.numeric(data[, 3]) attributes(data)$variable.labels[3] &lt;- &quot;Gender&quot; data[, 3] &lt;- factor(data[, 3], levels=c(1,2),labels=c(&quot;weiblich&quot;, &quot;männlich&quot;)) names(data)[3] &lt;- &quot;F1&quot; # LimeSurvey Field type: A ... Nach dem Laden der Datendatei (survey_791736_R_data_file.csv) werden Formatierungen der Datentypen und Vergabe von Variablennamen durchgeführt. Da Variablennamen von LimeSurvey vergeben werden, ist es in den meisten Fällen sinnvoll, diese manuell zu ändern. Auch eine genaue Kontrolle (und gegebenenfalls Korrektur) bei den Datentypen ist angebracht. Üblicherweise ändert sich eine Umfrage nach Freischaltung bezüglich ihrer Datenstruktur nicht mehr, daher ist dieser Aufwand auch nur einmalig durchzuführen. WICHTIG: bei allen folgenden Exports aus Limesurvey ist dann nur mehr die Datendatei zu exportieren - die Syntaxdatei braucht dann nicht mehr exportiert werden15! Datenvorverarbeitung Lade und überarbeite die Syntaxdatei (survey_791736_R_syntax_file.R). Beachte dabei folgende Punkte: Sonderzeichen werden oft nicht korrekt übernommen - verwende die RStudio-Funktion Search and Replace um alle falsch übertragenen Sonderzeichen zu korrigieren. Ändere die Variablennamen auf sinnvolle Namen (vgl. Attribute) Überprüfe die Datentypen sämtlicher Variablen. Ändere den Datentyp der Variablen falls notwendig. Nach erfolgter Überarbeitung kann das Skript in eine Funktion umgewandelt werden. Der Name der Funktion sollte dabei LS_Import.R lauten und als einziges Argument sollte die Variable F2L (für File t(w)o Load) angegeben werden. Hinweis: die Funktion read.csv() muss entsprechend angepasst werden! LS_Import &lt;- function(F2L) { data &lt;- read.csv(F2L, quote = &quot;&#39;\\&quot;&quot;, na.strings = c(&quot;&quot;, &quot;\\&quot;\\&quot;&quot;), stringsAsFactors = FALSE) # LimeSurvey Field type: F data[, 1] &lt;- as.numeric(data[, 1]) attributes(data)$variable.labels[1] &lt;- &quot;id&quot; names(data)[1] &lt;- &quot;id&quot; # LimeSurvey Field type: DATETIME23.2 ... Des Weiteren sollte am Ende der Funktion als Rückgabewert der Datenframe (data) angegeben werden (siehe nachfolgenden Codteil am Ende der LS_Import.R Funktion): ... names(data)[22] &lt;- &quot;WQ12&quot; return(data) } Aufgabe 1 Erstelle nun ein neues Skript (Name: 09_RLimeSurvey.R), in welchen du zuerst den Standard-Header kopierst (siehe nachfolgenden Code) und welches danach die Daten über die soeben erstellte Funktion lädt! Prüfe mit einer geeigneten Funktion die Struktur des geladenen Dataframes. #---- 09_RLS_Init rm(list = ls()) if (!require(&quot;pacman&quot;)) install.packages(&quot;pacman&quot;) pacman::p_load(here) Durch diese Funktion können die Daten fortlaufend auf dem aktuellen Stand gehalten werden. Der einzige Nachteil besteht noch darin, dass man manuell die Daten aus LimeSurvey exportieren muss. Dass kann allerdings automatisiert werden. Dazu braucht man nur den Zugang zur SQL-Datenbank von Limesurvey und die entsprechenden Pakete in R laden. Aus Datenschutzgründen ist es im Rahmen dieser LV nicht möglich, den Zugang zur LS-Datenbank freizuschalten, daher werden wir diese Möglichkeit nicht weiter besprechen. Es sei jedoch an dieser Stelle darauf hingewiesen, dass man mit einem entsprechenden Zugang zu den Daten auch die Möglichkeit hat, Skripte und Funktionen in R in die Aufgabenplanung eines Windows/Linux-Systems einzubauen (sogenannte chron-jobs) und damit ein vollständig automatisches Auswertesystem zu erstellen. Deskriptive Statistik Bei den nachfolgenden Aufgaben erzeugen wir deskriptive Statistiken in Form von Tabellen und einer Graphik. Aufgabe 2 Im Folgendem wollen wir und mit der einfachen Auswertung der vorliegenden Daten beschäftigen. Die ersten Schritte einer Datenauswertung beginnen i.A. mit einer deskriptiven Statistik. Aufgrund der vorwiegend nominalen Daten des Fragebogens eignen sich am besten Häufigkeitstabellen. Erstelle daher folgende Tabellen (verwende dazu die Funktion table()): Anzahl der Männer und Frauen die an der Umfrage teilgenommen haben. Anzahl der Personen je Nation. Anzahl der Personen nur jener Nationen, die an der Umfrage teilgenommen haben16. Anzahl der Personen nur jener Nationen, die an der Umfrage teilgenommen haben, getrennt nach Geschlecht. Gleich wie Aufgabe 4, nur mit zusätzlicher Angabe der Randsummen! Gleich wie Aufgabe 5, nur die auf 2 Stellen gerundeten Angaben in Prozent17. Aufgabe 3 Ein zur deskriptiven Analyse hilfreiches Paket ist doBy. Wir wollen die darin enthaltene Funktion summaryBy() verwenden, um folgende Aufgabenstellungen zu lösen: Berechne das Durchschnittsalter getrennt nach Geschlecht. Berechne den Mittelwert, die Standardabweichung, die Varianz, das Minimum und das Maximum der Variablen Alter getrennt nach Geschlecht. Berechne das Durchschnittsalter getrennt nach Geschlecht und Nationalität. Berechne den Mittelwert, die Standardabweichung, die Varianz, das Minimum und das Maximum der Variablen Alter getrennt nach Geschlecht und Nationalität. Das Paket doBy bietet darüber hinaus eine Vielzahl von Funktionen, die vor allem für das Arbeiten mit gruppierten Daten sehr hilfreich sein können. Hingewiesen sei noch auf die Möglichkeit der Berechnung von Kontrasten im Rahmen einer least square mean (ANOVA) Analyse. Es würde den Rahmen dieser LV sprengen, alle verfügbaren Funktionen zu besprechen und zu verwenden. Weitere Details zu diesem Paket sind der Dokumentation zu entnehmen. Aufgabe 4 Neben den Tabellen spielen Graphiken eine wesentliche Rolle in der deskriptiven Statistik. In dieser Aufgabe wollen wir mit dem Paket ggplot2 ein Balkendiagramm erstellen, welche für die erste Frage des Tests die prozentuellen Anteile pro Antwortkategorie getrennt nach Geschlecht darstellt. Darüber hinaus sollte in dieser Graphik auch jeweils ein Balken pro Antwortkategorie für den prozentuellen Anteil unabhängig vom Geschlecht angezeigt werden. Folgende Graphik stellt das gewünschte Ergebnis dar: Abbildung 33: Vorlage für die Graphik der Aufgabe 4 Um die Aufgabe auf das eigentliche Ziel (eine Graphik zu erstellen) zu beschränken, kannst du den folgenden Code in dein R-Skript kopieren (diskutiere das Ergebnis dieses Codefragmentes)18: library(ggplot2) LegTit &lt;- paste0(&#39;Overall (N = &#39;, dim(DF)[1], &#39;) answers in %&#39;) ColInd &lt;- which(colnames(DF) %in% c(&quot;WQ1&quot;)) WQ_Label &lt;- attributes(DF)$variable.labels[ColInd] CT &lt;- round(100*addmargins(prop.table(table(DF[,ColInd], DF$Gender)), margin = 2), 2) DF_CT &lt;- as.data.frame(CT) colnames(DF_CT) &lt;- c(&quot;Answer&quot;, &quot;Gender&quot;, &quot;Percent&quot;) Ergänze nun den Code mit der entsprechenden Funktion zur Erstellung dieser Graphik und ergänze/ändere den Graphen nach folgenden Vorgaben: Drehe die Koordinaten 90 Grad (verwende die Funktion coord_flip()). Die x-Achsenbeschriftung sollte Answer sein (verwende die Funktion xlab()). Die Beschriftung der Legende sollte dem bereits definierten Text der Variablen LegTit entsprechen (verwende die Funktion guides(fill = guide_legend(title = ???))). Verwende die Funktion labs(), um Titel (= WQ_Label), Subtitel (= “World Knowledge Test”), Caption (= “Source: World Knowledge Query PLUS (2018)”, tag (= “A”) anzuzeigen. Ändere das Farbschema des Graphen auf Grauschattierungen (verwende die Funktion scale_fill_grey()). Zeige über den Balken die jeweilig erreichten Prozentwerte an (verwende die Funktion geom_text(aes(label = paste0(round(???, 1), “%”)), position = position_dodge(width=0.9), hjust = -0.25)). Ändere den Hintergrund der Graphik auf Transparent (verwende die Funktion theme_bw()). Der fertige Graph sollte folgendermaßen aussehen: Abbildung 34: Endversion der Graphik von Aufgabe 4 Lösungen Lösung Aufgabe 1 source(&quot;RScripts/LS_Import.R&quot;) F2L &lt;- &quot;Data/survey_791736_R_data_file.csv&quot; DF &lt;- LS_Import(F2L = F2L) str(DF) Lösung Aufgabe 2 table(DF$Gender) # A2-1 table(DF$Nationality) # A2-2 table(droplevels(DF$Nationality)) # A2-3 table(DF$Gender, droplevels(DF$Nationality)) # A2-4 addmargins(table(DF$Gender, droplevels(DF$Nationality))) # A2-5 addmargins(round(prop.table(table(DF$Gender, droplevels(DF$Nationality)))*100,2)) # A2-6 Lösung Aufgabe 3 library(doBy) summaryBy(formula = Age ~ Gender, data = DF) # A3-1 summaryBy(formula = Age ~ Gender, data = DF, FUN = c(mean, sd, var, min, max)) # A3-2 summaryBy(formula = Age ~ Gender + Nationality, data = DF) # A3-3 summaryBy(formula = Age ~ Gender + Nationality, data = DF, FUN = c(mean, sd, var)) # A3-4 Lösung Aufgabe 4 library(ggplot2) LegTit &lt;- paste0(&#39;Overall (N = &#39;, dim(DF)[1], &#39;) answers in %&#39;) ColInd &lt;- which(colnames(DF) %in% c(&quot;WQ1&quot;)) WQ_Label &lt;- attributes(DF)$variable.labels[ColInd] CT &lt;- round(100*addmargins(prop.table(table(DF[,ColInd], DF$Gender)), margin = 2), 2) DF_CT &lt;- as.data.frame(CT) colnames(DF_CT) &lt;- c(&quot;Answer&quot;, &quot;Gender&quot;, &quot;Percent&quot;) ggplot(DF_CT, aes(x = Answer, y = Percent, fill = Gender)) + geom_bar(position = position_dodge(), stat = &quot;identity&quot;, colour = &quot;black&quot;, # Use black outlines, size = .3) + coord_flip() + xlab(&quot;Answer&quot;) + guides(fill = guide_legend(title = LegTit)) + labs(title = WQ_Label, subtitle = &quot;World Knowledge Test&quot;, caption = &quot;Source: World Knowledge Query PLUS (2018)&quot;, tag = &quot;A&quot;) + scale_fill_grey() + geom_text(aes(label = paste0(round(Percent, 1), &quot;%&quot;)), position = position_dodge(width=0.9), hjust = -0.25) + theme_bw() es sei denn, die Struktur der Umfrage ändert sich wider erwarten!↩ Hinweis: verwende die Funktion droplevels()↩ Hinweis: runden mit der Funktion round(), Prozente mit der Funktion prop.table()↩ die Definition von LegTit und WQ_Label wird in einer Folgeaufgabe noch zur weiteren Gestaltung der Graphik verwendet.↩ "],
["bedingungen-und-schleifen.html", "10 Bedingungen und Schleifen Bedingte Ausführung Iterationen in R Die while- und repeat Schleife Lösungen", " 10 Bedingungen und Schleifen Bedingte Ausführung Normalerweise wird ein R-Code Zeile für Zeile, von oben nach unten, ausgeführt. Manchmal möchte man aber eine Zeile - oder einen ganzen Block von Zeilen - nur unter einer bestimmten Bedingung durchführen. Dazu bietet sich in R die If-Anweisung an. Einfache If-Bedingung Folgende Abbildung zeigt die Programmlogik für eine einfache If-Bedingung: Abbildung 35: Einfaches If Mit folgendem Code kann diese einfache Entscheidung umgesetzt werden: punkte &lt;- 90 if (punkte &gt;= 90) { print(&quot;Sehr gut&quot;) } Else-If-Bedingung Trifft eine Bedinung nicht zu, kann mit Hilfe der Else-If-Bedingung eine weitere Bedingung überprüft werden: Abbildung 36: Die If-Else Bedingung Folgender Code zeigt die Syntax, mit der eine derartige Überprüfung in R umgesetzt werden kann: punkte &lt;- 85 if (punkte &gt;= 90) { print(&quot;Sehr gut&quot;) } else if (punkte &gt;= 80 &amp; punkte &lt; 90) { print(&quot;Gut&quot;); } else { print(&quot;Nicht genÃ¼gend&quot;); } Bemerkung: bei genauer Betrachtung des Codes kann man feststellen, dass neben der if () und der else if () auch eine generelle else () Anweisung am Ende der Entscheidungslogik verwendet werden kann (aber nicht unbedingt muss). Diese Logik lässt sich nun für weitere Abfragen erweitern. Aufgabe 1 Erweitere den Code, sodass für eine beliebige Eingabe von Punkte zwischen 0 und 100 folgende Ausgabe erzeugt wird: \\(&gt;= 90 \\rightarrow\\) Sehr gut \\(&gt;= 80 \\&amp; &lt; 90 \\rightarrow\\) Gut \\(&gt;= 70 \\&amp; &lt; 80 \\rightarrow\\) Befriedigend \\(&gt;= 60 \\&amp; &lt; 70 \\rightarrow\\) Genügend \\(&lt; 60 \\rightarrow\\) Nicht genügend Hier findest du die Lösung zur Aufgabe. Die ifelse Bedingung Eine weitere Möglichkeit bietet noch die folgende ifelse(test_expression, x, y) Funktion. Betrachte folgendes Beispiel: punkte &lt;- sample(1:100, 10) ifelse(punkte &lt; 60, &quot;Nicht genÃ¼gend&quot;, &quot;Bestanden&quot;) Iterationen in R Sinn und Zweck von Iterationen (Schleifen, Loops) ist es, einen Code \\(n\\)-mal auszuführen. Die Variable \\(n\\) ist hierbei eine ganze Zahl (integer) und in der Regel beim Start der Schleife mit einem festen Wert definiert. In R stehen folgende Loop-Strukturen zur Verfügung: Abbildung 37: Loop-Strukturen in R Diese Schleifen unterscheiden sich dahingehend: For-Loop: führt eine Instruktion (\\(i1\\), \\(i2\\), etc.) so oft durch, bis das Ende einer vordefinierten Sequenz (z.B. 1:100) erreicht ist. While-Loop: so lange eine Bedingung zutrifft (wahr ist), werden die Instruktionen \\(i1\\), \\(i2\\), etc. ausgeführt. Der while-loop wird dann beendet, wenn die Bedingung von wahr auf falsch wechselt. Repeat-Loop: ähnlich dem while, nur dass die Instruktion \\(i1\\) und \\(i2\\) zumindest einmal ausgführt werden und zwar unabhängig davon, was die Bedingung am Ende der Schleife ergibt. Die for-Schleife Die Syntax einer for-Schleife ist relativ simple: n &lt;- 5 for(i in 0:n) { print(i); } Manchmal kann es erforderlich sein, eine bestimmte Iteration zu unterbrechen und zum nächsten Durchlauf weiterzugehen. Dies kann man mit dem next-Befehl erreichen, wie folgender Code zeigt: m &lt;- 20 for (k in 1:m){ if (!k %% 2) next print(k) } Eine einfache Anwendung einer for-Schleife wird im nachfolgenden Code demonstriert. Um eine For-Schleife vorzeitig zu beenden - wenn z.B. ein besonderes Ereignis während der Abarbeitung des Codes eintritt - kann man mit der Funktion break den sofortigen Ausstieg aus der Schleife erzwingen. Ein derartiger frühzeitiger Ausstieg aus einer Schleife ist im nachfolgenden Code zum Zweck der Veranschaulichung eingebaut (macht inhaltlich aber bei diesem Beispiel nicht wirklich viel Sinn). Kopier den Code in dein Skript, führe ihn aus und diskutiere die Eigenschaften und das Ergebnis. # Create a vector filled with random normal values u1 &lt;- rnorm(30) print(&quot;This loop calculates the square of the first 10 elements of vector u1&quot;) # Initialize `usq` usq &lt;- 0 for(i in 1:10) { # i-th element of `u1` squared into `i`-th position of `usq` usq[i] &lt;- u1[i]*u1[i] print(usq[i]) } print(i) For-Schleifen kommen vor allem bei Berechnungen in Matrizen auch in verschachtelter Form vor. Betrachte das folgende Beispiel und diskutiere die Eigenschaften dieser Schleife(n): # Insert your own integer here my_int &lt;- 20 nr &lt;- as.integer(my_int) # Create a n x n matrix with zeroes mymat &lt;- matrix(0, nr, nr) # For each row and for each column, assign values based on position # These values are the product of two indexes for(i in 1:dim(mymat)[1]) { for(j in 1:dim(mymat)[2]) { mymat[i,j] = i*j } # Just for the sake of demonstrating the break function: # Exit the loop when number of rows = 5 if (i == 5) break } # Show the first 10x10 chunk or the first `nr` x `nr` chunk if (nr &gt; 10) { mymat[1:10, 1:10] } else mymat[1:nr, 1:nr] For-Schleifen sind wahrscheinlich die am häufigst verwendete Form von Schleifen. Ist jedoch die Anzahl der Durchläufe einer/mehrerer Codezeilen jedoch nicht vorher bestimmbar, sondern abhängig davon, ob eine bestimmte Bedingung erfüllt ist, muss man die while (oder repeat) Schleife verwenden. Bemerkung zu For-Loops For-Loops haben bestimmte Nachteile, weswegen sie auch nach Möglichkeit vermieden werden sollten. Das heißt nicht, dass man for-loops prinzipiell nicht verwenden sollte, aber man sollte sich überlegen, ob for-loops nicht anders gelöst werden könnten. Die Nachteile sind: for-loops sind langsam. es ist manchmal schwer nachvollziehbar, was genau gemacht wird - speziell bei verschachtelten Loops. Fehlersuche ist in loops (manchmal) mühsam. Kontrolle der Funktionalität liegt beim Entwickler - Alternativen zu for-loops sind hingegen gestestet und reduzieren daher die Fehlerwahrscheinlichkeit enorm. For-loops könnten oft durch bestehende Funktionen - die sogenannten funtionals - vermieden werden. Im folgenden wollen wir uns kurz mit der Familie der apply() Funktionen beschäftigen. apply() Die apply()-Funktionen arbeiten im Wesentlichen mit for-loops, sind jedoch i.A. weit effizienter und vor allem bereits auf ihre Funktionalität geprüft. In der apply()-Familie finden sich folgende Funktionen: apply() und tapply(): für Matrizen und Arrays, das tapply() entspricht einer Verallgemeinerung von apply() und kann auf Arrays ungleicher Größe angewendet werden (also wenn jede Zeile eine andere Anzahl Spalten hat). lapply(): Anwendung auf Listen mit einem Output als Liste. sapply() und vapply(): Anwendung auf Listen mit einem Output als einfachen Vektor. mapply(): für multiple Listen, der Output ist wieder eine Liste. tapply(): für Arrays, deren Elemente unterschiedliche Größe aufweisen. Die Wirkungsweise der apply() Funktion kann dem nachfolgenden Code entnommen werden: # apply() a &lt;- matrix(1:20, nrow = 5) apply(a, 1, mean) # tapply() pulse &lt;- round(rnorm(22, 70, 10 / 3)) + rep(c(0, 5), c(10, 12)) group &lt;- rep(c(&quot;A&quot;, &quot;B&quot;), c(10, 12)) tapply(X = pulse, INDEX = group, FUN = length) lapply() Ein einfaches functional der apply()-Familie ist die lapply()-Funktion. Mit dieser Funktion wird eine bestimmte Funktion (z.B. der Mittelwert) auf jedes Element einer Liste angewendet. Nachfolgende Abbildung zeigt die Wirkungsweise von lapply(). Abbildung 38: Wirkungsweise von lapply() Aus Gründen der Verarbeitungsgeschwindigkeit ist diese Funktion in C geschrieben, aber im Wesentlichen entspricht sie folgenden R-Code: lapply2 &lt;- function(x, f, ...) { out &lt;- vector(&quot;list&quot;, length(x)) for (i in seq_along(x)) { out[[i]] &lt;- f(x[[i]], ...) } out } Diese Funktion verwendet im Kern einen for-loop. Da innerhalb der Funktion (lapply2()) eine weitere Funktion (f(x)) angewendet wird, nennt man das Ganze auch functional. Folgender Code veranschaulicht die Funktionsweise von lapply: # Create some random data l &lt;- replicate(20, runif(sample(1:10, 1)), simplify = FALSE) # With a for loop out &lt;- vector(&quot;list&quot;, length(l)) for (i in seq_along(l)) { out[[i]] &lt;- length(l[[i]]) } unlist(out) #------------------------- # With lapply unlist(lapply(l, length)) #------------------------- sapply() und vapply() Die beiden funcitonals sapply() und vapply() funktionieren im Prinzip gleich wie lapply(), mit dem Unterschied, dass der Output nicht als Liste, sondern als Vektoren zurückgegeben wird. Betrachte folgenden Anwendung der beiden Funktionen: sapply(mtcars, is.numeric) sapply(mtcars, mean) vapply(mtcars, is.numeric, logical(1)) Beide Funktionen erzielen genau dasselbe Resultat. Die Unterschiede sind: sapply() eignet sich besser für interaktives arbeiten, da weniger einzugeben ist. vapply() eignet sich besser bei der Anwendung innerhalb von Funktionen, da diese Funktion im Fall von Fehlern während der Ausführung weit bessere Rückmeldung an den Programmierer liefert als sapply! Map() Für multiple Inputs eignet sich die Map()19 Funkion. Betrachte nachfolgendes Beispiel: # Generate some sample data xs &lt;- replicate(5, runif(10), simplify = FALSE) ws &lt;- replicate(5, rpois(10, 5) + 1, simplify = FALSE) unlist(Map(weighted.mean, xs, ws)) Die while- und repeat Schleife Ist der Durchlauf von Codezeilen abhängig von einer Bedingung, verwendet man den while-loop. Betrachte einfach den nachfolgenden Code und diskutiere die Eigenschaften der Schleife! Corr_Resp &lt;- FALSE while (Corr_Resp == FALSE) { response &lt;- readline(prompt = &quot;What is the correct answer to life, the universe and everything? Please, enter your ANSWER: &quot;) if (response == &quot;42&quot;) { print(&quot;Cool, you obviously read the right books!&quot;) Corr_Resp &lt;- TRUE } else { print(&quot;Sorry, the answer is incorrect, try again!&quot;) } } Wie sofort klar sein sollte, kann es bei while-loops bezüglich der Abbruchbedingung problematisch werden. Dies gilt auch für den repeat-loop. Betrachte nachfolgendes Beispiel. Vergleiche dieses mit dem while-loop und diskutiere den Unterschied! repeat { response &lt;- readline(prompt = &quot;What is the correct answer to life, the universe and everything? Please, enter your ANSWER: &quot;) if (response == &quot;42&quot;) { print(&quot;Cool, you obviously read the right books!&quot;); break } else print(&quot;Sorry, the answer is incorrect, try again!&quot;); } Aufgabe 2 Im ersten Schritt soll eine \\(m \\times n\\) Matrix mit lauter Nullen erstellt werden. Mit einer verschachtelten Schleife soll nun in jede Zelle die sich unterhalb der Diagonale befindet, das Produkt der aktuellen Zeile \\(\\times\\) Spalte geschrieben werden. Das Resultat für eine \\(n = 10 \\times m = 10\\) sollte also folgendermaßen aussehen: 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 3 6 0 0 0 0 0 0 0 0 4 8 12 0 0 0 0 0 0 0 5 10 15 20 0 0 0 0 0 0 6 12 18 24 30 0 0 0 0 0 7 14 21 28 35 42 0 0 0 0 8 16 24 32 40 48 56 0 0 0 9 18 27 36 45 54 63 72 0 0 10 20 30 40 50 60 70 80 90 0 Verwende den nachstehenden Code um die Aufgabe zu lösen. Ersetze dabei die Platzhalter (XXX) durch die entsprechenden Indices, Variablen, etc. # Make a lower triangular matrix (zeroes in upper right corner) m &lt;- 10 # number of rows in matrix n &lt;- 10 # number of columnes in matrix ctr &lt;- 0 # a counter to count the assignment mymat &lt;- matrix(data = 0, nrow = m, ncol = n) # Create a 10 x 10 matrix with zeroes for(i in 1 : XXX) { for(j in 1 : XXX) { if(XXX == XXX) { break; } else { # you assign the values only when i&lt;&gt;j mymat[XXX,XXX] &lt;- XXX * XXX ctr &lt;- ctr + 1 } } print(XXX * XXX) } print(paste(&#39;There are&#39;, XXX, &quot;cells in the matrix&quot;)) # Print how many matrix cells were assigned print(paste(&#39;There are&#39;, XXX, &quot;cells assigned with values in the matrix&quot;)) # Print how many matrix cells were assigned Hier findest du die Lösung zur Aufgabe. Lösungen Aufgabe 1 Lsg punkte &lt;- 85 if (punkte &gt;= 90) { print(&quot;Sehr gut&quot;) } else if (punkte &gt;= 80 &amp; punkte &lt; 90) { print(&quot;Gut&quot;); } else if (punkte &gt;= 70 &amp; punkte &lt; 90) { print(&quot;Befriedigend&quot;); } else if (punkte &gt;= 60 &amp; punkte &lt; 70) { print(&quot;genÃ¼gend&quot;); } else { print(&quot;Nicht genÃ¼gend&quot;); } zurück zur Aufgabe Aufgabe 2 Lsg # Make a lower triangular matrix (zeroes in upper right corner) m &lt;- 10 # number of rows in matrix n &lt;- 10 # number of columnes in matrix ctr &lt;- 0 # a counter to count the assignment mymat &lt;- matrix(data = 0, nrow = m, ncol = n) # Create a 10 x 10 matrix with zeroes for(i in 1 : m) { for(j in 1 : n) { if(i == j) { break; } else { # you assign the values only when i&lt;&gt;j mymat[i,j] &lt;- i * j ctr &lt;- ctr + 1 } } print(i * j) } print(paste(&#39;There are&#39;, length(mymat), &quot;cells in the matrix&quot;)) # Print how many matrix cells were assigned print(paste(&#39;There are&#39;, ctr, &quot;cells assigned with values in the matrix&quot;)) # Print how many matrix cells were assigned zurück zur Aufgabe mapply(…, simpligy = FALSE) ist die genau dieselbe Funktion wie Map().↩ "]
]
